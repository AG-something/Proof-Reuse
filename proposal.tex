\documentclass[letterpaper, 11pt]{article}

\usepackage{amsmath, amssymb, amsfonts}%math
\usepackage{mathtools}
\usepackage[left=2cm,right=2cm,top=2.75cm,bottom=2.75cm]{geometry}%margins
\usepackage[utf8x]{inputenc}%ASCII characters
\usepackage[T1]{fontenc}
\usepackage{lmodern}%for accentuated characters and accents
\usepackage{graphicx}%inserting pdf-jpg pictures
\usepackage[natural, dvipsnames, pdftex]{xcolor}
\usepackage{tikz} %Drawing pretty pictures
\usepackage{verbatim} %adding code
\usepackage{listings} % adding code that contains symbols
\usepackage[pdftex,  colorlinks=true]{hyperref}%Hyperlinks, with \href
\hypersetup{urlcolor=RoyalBlue,  linkcolor=RedOrange,  citecolor=black}

\usepackage{proof} %for proof trees
\usepackage{mathdots}

\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{n} %mathpzc alphabet
\usepackage[mathscr]{eucal} %mathscr alphabet

\usepackage{stmaryrd} %Bold brackets (for meta-substitutions)

%Redefine theorem environments
\usepackage[amsmath,  thref,  thmmarks,  hyperref]{ntheorem}


%Redefining theorem style
\theoremheaderfont{\bf}
\theorembodyfont{\normalfont}


\newtheorem*{theorem}{Theorem}[section]
\newtheorem*{lemma}[subsection]{Lemma}
\newtheorem{cor}[subsection]{Corollary}
\newtheorem{prop}[subsection]{Proposition}
\newtheorem*{claim}{Claim}
\newtheorem*{sol}{Solution}
\newtheorem{defn}[theorem]{Definition}
\newtheorem{ex}{Example}[section]
\newtheorem*{remark}{Remark}[section]
\newtheorem*{obs}{Observation}[section]
\newtheorem*{note}{Note}[section]
\renewcommand{\Box}{\rule{1.5ex}{1.5ex}}  % end of proof


\newenvironment*{proof}{\par\noindent{\normalfont{\bf{Proof. \\ \hphantom{mm}
}}}}{\hfill \small$\blacksquare$\\[-4pt]}


\usepackage{verbments}%fancy verbatim
\usepackage[shortlabels]{enumitem}

\newcommand{\mlcomment}[1]{} % multi-line comments (not great since it still processes the argument)


% Calligraphic letters
\newcommand{\D}{\mathcal{D}}


% Symbols
\newcommand{\Rar}{\Rightarrow}
\newcommand{\Lar}{\Leftarrow}
\newcommand{\rar}{\rightarrow}


%% keywords
% Syntax
\newcommand{\Type}{\texttt{Type}}
\newcommand{\Rec}{\texttt{Rec}}
\newcommand{\Sort}{\texttt{Sort}}
\newcommand{\wk}{\texttt{wk}}
\newcommand{\proj}{\texttt{proj}}
\newcommand{\Clo}{\texttt{Clo}}

\newcommand{\ctype}{\texttt{ctype}}
\newcommand{\csort}{\texttt{csort}}
\newcommand{\rec}{\texttt{rec}}
\newcommand{\fn}{\texttt{fn}}
\newcommand{\case}{\texttt{case}}
\newcommand{\of}{\texttt{of}}
\newcommand{\bbox}{\texttt{box}}
\newcommand{\sbbox}{\texttt{sbox}}

% Judgments
\newcommand{\block}{\texttt{block}}
\newcommand{\world}{\texttt{world}}
\newcommand{\schema}{\texttt{schema}}
\newcommand{\ctx}{\texttt{ctx}}
\newcommand{\mctx}{\texttt{mctx}}
\newcommand{\sctx}{\texttt{sctx}}
\newcommand{\sig}{\texttt{sig}}
\newcommand{\kind}{\texttt{kind}}

\newcommand{\cctx}{\texttt{cctx}}

\title{Proof Reuse}
\date{\today}
\author{Antoine Gaulin}


\begin{document}
    \maketitle

    \section{Introduction}
    % The whole introduction needs to be rewritten.
    % The project now focuses exclusively on refinements, constructor subtyping and ornaments are left for later
    %  *  So, maybe the title should change as well
    %  ** Hurray for easy 'further work' section


    % First paragraph is very bad, need an actual sujet amene
    It is common in the literature to reuse proofs of previously established results in order to derive new theorems.  A common pattern in papers
    is to start from a well understood language (often System F, LF, or the Calculus of Construction), add a new construct to it (e.g. subtyping,
    inductive types, etc.), and then show that the desirable properties of the original system are preserved.  Most proofs (at least for the basic
    properties) are by induction on the structure of the hypothesized derivation.  To conclude that the properties hold in the extension, it is then
    clearly sufficient to consider only the cases relevant to the new construct.  However, in mechanization, one would need to work through all the
    previously established cases once more.  This task is tedious and unnecessary.

    We investigate a few ways to simplify the development of mechanized proofs, the key idea being to reuse proofs when possible.
    The aim is to start from the type system of Beluga \cite{Pientka2008, PientkaDunfield2008} and look at a few extensions that allow 
    various forms of proof reuse.
    Through this process, we can also fix a major problem with how contexts are represented in Beluga, namely the inability to
    recover premisses needed for the formation of assumptions.

    The first direction is to extend the data-level type theory (i.e. the logical framework LF \cite{LF1987}) with refinements, 
    thus allowing a restricted form of subtyping to the language.
    This can then be lifted to context schemas, and then to the computation-level (i.e. the dependent contextual modal type theory \cite{Nanevski2008})
    in a mostly straightforward way.  The main idea behind refinements is to ``separate'' a type into \textit{sorts}.  While types express
    syntactic properties of terms, sorts express semantic properties.  They can therefore be used to enforce various properties on terms,
    while preserving type uniqueness.  In this case, we obtain a notion of subsorting rather than subtyping.  Ultimately, refinements allow
    a very limited form of proof reuse, and their usefulness is more in simplifying proofs.
    
    The second direction is to add constructor subtyping \cite{Poll1997, BarthesFrade1999}, which would be more accurately called \textit{supertyping}.
    This idea is simple : if a type $B$ has all the constuctors of another type $A$ and possibly more, then $B$ can be viewed as a supertype of $A$.
    Intuitively, this is because any object constructed with only the constructors defining $A$ could also be constructed by the constructors defining $B$.
    In this setting, we get a notion of co-inheritance \cite{Poll1997}.  This can be seen as dual to the inheritance mechanisms of object oriented programming,
    in the sense that a co-inherited function is lifted from a subtype to its supertype, and then extended with the cases to cover the extra constructors 
    (if needed).
    
    % Might ditch ornaments for now, it's kind of complicated and mysterious
    The third direction is to add ornaments \cite{McBride2011}.  Here, we obtain systematic ways to enhance a type and/or its constructors with 
    additional dependencies, as well as a lifting mechanism to lift proofs on a type to its ornamented type.  Combining this with constructor subtyping,
    we should be able to present incremental development of languages and of their meta-theory, which would be closer to what is found in the literature.

    \textbf{Note}. In what follows, the comments classified as \textbf{Remark} are clarifications or observations, and those classified as \textbf{Note} 
    are either things that I didn't think of before I started typing this down, or places where I realized there is a mistake.


%    \section{A refinement type system for Beluga}
    
    We start with refinements because it is the most invasive change to the language.  This is due to the fact that we now want to assign both sorts
    and types to terms, which is done in a single judgment.  This change is also present at the level of types, which are classified by both classes
    and kinds.  Thus, almost every inference rule must be adapted, although they keep the same flavor.  The core theory presented in this section is
    based on \cite{Pientka2008} and \cite{PientkaDunfield2008}, and the addition of refinements closely follows what is shown in \cite{LovasPfenning2010}.

    In the setting of refinements, every object should have a unique type (fully determined by its syntax), but possibly many different sorts.  Each 
    sort is restricted to a given type, and they express more specific properties that may of may not be satisfied by a given term of that type.  In 
    this sense, one may regard types as intrinsic properties, and sorts as extrinsic properties \cite{Pfenning2000}.  This allows us to specify properties
    without the need for additional types, which in turns simplifies the statement of theorems and their proofs.  Additionally, there is a natural 
    sub-sorting relation that is akin to logical implication, that is $S_1 \leq S_2 \sqsubset A$ if the property $S_1$ implies the property $S_2$ for
    any term of type $A$.  In particular, if we have proven a result on terms of sort $S_2$, then we can reuse the proof on terms of sort $S_1$.

    \section{Motivating Examples}

    \subsection{Values and Terms}
    
    In a framework without refinements, being a value is usually encoded as a property of terms, i.e. as a type of kind \texttt{tm -> type}.  When
    refinements are added, it becomes simpler to have a sort of values refining the type of terms.  So, an encoding of the $\lambda$-calculus with
    natural numbers could be the following :

    \begin{lstlisting}[mathescape, basicstyle=\fontfamily{lmvtt}\selectfont]
      LF term : type =
        | value : sort
        | zero : value
        | succ : (value -> value) $\land$ (term -> term)
        | lam : (value -> term) -> value
        | app : term -> term -> term
      ;
    \end{lstlisting}

    Here, we make use of intersection sorts when specifying the \texttt{succ} constructors, which can be applied to arbitrary terms, but should only 
    yield a value when it is applied to a value. Note also that the \texttt{lam} constructor is given sort \texttt{(value -> term) -> value}, which 
    enforces a call-by-value semantic in the language.  Now, let's define a big-step semantics for this small language :

    \begin{lstlisting}[mathescape, basicstyle=\fontfamily{lmvtt}\selectfont]
      LF big_step : term -> value -> type =
        | bs_zero : big_step zero zero
        | bs_succ : big_step M V -> big_step (succ M) (succ V)
        | bs_lam : big_step (lam M) (lam M)
        | bs_app : big_step F (lam M) 
                   -> big_step N V' 
                   -> big_step (M V') V 
                   -> big_step (app F N) V
    \end{lstlisting}

    Without refinements, our big-step semantics would instead have kind \texttt{term -> term -> type}, and the first thing that we would want is to prove 
    that if \texttt{big\_step M V}, then \texttt{V} is a value.  Adding refinements allows us to specify this property directly and verify it automatically
    at type-checking, thus reducing the number of lemmas that one needs to prove about their language.

    It should be noted that this improvement can be done without the use of refinements, by first defining a type of values and having a term constructor 
    that lifts all values to terms, that is a constructor of type \texttt{value -> term}.  However, this approach creates an unnecessary separation between
    values and terms, whereas refinements merely distinguish values as a special subset of terms.  Due to this separation, if we want to prove a lemma that 
    holds of arbitrary terms (possibly with some restriction), we often need to first prove a separate lemma just for values, so that we can use it to handle
    the case of values.  When considering values as a sort refining terms, this should not be necessary since we 

    \subsection{Bidirectional Typing}
    
    In bidirectional typing, we separate terms in two categories, normal and neutral, which correspond to introduction and elimination forms, respectively.  
    The type of a neutral term is synthesized, while the type of a normal term is checked.  So, a simply-typed $\lambda$-calculus with a base type and a 
    constant would have the following syntax :

    \begin{center}
      \begin{tabular}{rrl}
        Types          & $A,B ::=$ & $\texttt{b} \mid A \rar B$ \\
        Normal terms   & $M,N ::=$ & $R \mid \texttt{c} \mid \lambda x. M$ \\
        Neutral terms  & $R ::=$   & $x \mid R \ M$
      \end{tabular}
    \end{center}

    To encode this without refinements, we would usually start with a type \texttt{tm : type} of terms, and define normal and neutral as predicates of kind 
    \texttt{tm -> type}.  Alternatively, we could encode normal and neutral terms directly, following the above syntax.  However, this would make it more
    difficult to prove lemmas pertaining to all terms, as we would likely need to separate such a lemma in two parts, one for normal terms, and one for 
    neutral terms.  Using refinements, we can give the following encoding instead :

    \begin{lstlisting}[mathescape, basicstyle=\fontfamily{lmvtt}\selectfont]
      LF tp : type = 
        | base : tp
        | arr : tp -> tp -> tp
      ;

      LF tm : type =
        | normal : sort
        | neutral : sort
        | neutral $\leq$ normal
        | const : normal
        | lam : (term -> normal) -> normal
        | app : neutral -> normal -> neutral
      ;
    \end{lstlisting}

    In this definition, we use the subsorting mechanism to encode the fact that neutral terms can be considered as normal, rather than having a special 
    constructor just for that.  Now for the typing judgment, we can similarly use sorts to define a single type separated in two sorts :

    \begin{lstlisting}[mathescape, basicstyle=\fontfamily{lmvtt}\selectfont]
      LF has_type : tm -> tp -> type =
        | check : normal -> tp -> sort
        | synth : neutral -> tp -> sort
        | ht_switch : synth R A -> check R A
        | ht_const : check const base
        | ht_lam : ({x : neutral} synth x A -> check M B) 
                   -> check (lam M) (arr A B)
        |ht_app : synth R (arr A B) -> check M A -> synth (app R M) B
      ;
    \end{lstlisting}

    So, the use of refinments allows us to give a much more compact encoding of the types.


    \textbf{Note}.  There should be at least one proof in the example section

    \section{Data-level}
    The data-level of Beluga includes the usual terms, types, and kinds, but also contexts and substitutions.  We add to the type level a notion of sorts,
    and to the kind level a similar notion of classes.  Contexts are classified using a notion of schema, which, in our extension, are built out of
    world declarations.  A world is a record of assumptions satisfying certain properties.  To ensure well-formedness of worlds, we use two syntactic
    categories : blocks and worlds.  A block is a dependent record (i.e. $\Sigma$-type), and a world is a function space whose image is a block.

    \subsection{Syntax}
    \begin{figure}[tbh]
        \centering
        \begin{tabular}{rrl}
            Signatures              & $ \Sigma ::= $  & $ \cdot \mid \Sigma, D $ \\
%
            Declarations            & $ D ::= $       & $ \textbf{s} {::}L \sqsubset \textbf{a} {:} K \mid \textbf{c} {::} S \sqsubset A 
                                                          \mid \textbf{s}_1 \leq \textbf{s}_2 \sqsubset \textbf{a} \mid \textbf{w} {:} W 
                                                          \mid \boldsymbol{\xi} {:} \Xi $ \\
%
            Meta-contexts           & $ \Delta ::= $  & $ \cdot \mid \Delta, u{::}S[\Psi] \sqsubset A[\Psi] \mid \Delta, p{::}S[\Psi] \sqsubset A[\Psi]
                                                          \mid \Delta, s{:} \Psi_1[\Psi_2] \mid \Delta, \psi {:} \Xi$  \\
%
%            Schema contexts         & $ \Omega ::= $  & $ \cdot \mid \Omega, \psi  {:} \Xi $ \\
                                    &                 & \\
            Kinds                   & $ K ::= $       & $ \Type \mid \Pi x{:}A.K$ \\
            Classes                 & $ L ::= $       & $ \Sort \mid \Pi x{::}S. L \mid \top \mid L_1 \land L_2 $ \\
                                    &                 &  \\
            Atomic type families    & $ P ::= $       & $ \textbf{a} \mid P \ N $ \\
            Canonical type families & $ A ::= $       & $ P \mid \Pi x{:}A_1.A_2 $ \\
            %
            Atomic sort families    & $ Q ::= $       & $ \textbf{s} \mid Q \ N $ \\
            Canonical sort families & $ S ::= $       & $ Q \mid \Pi x{:}S_1 .S_2 \mid \top \mid S_1 \land S_2 $ \\
                                    &                 & \\
            Blocks                  & $ B ::= $       & $ S \sqsubset A \mid \Sigma x{::}S \sqsubset A. B$ \\
            Worlds                  & $ W ::= $       & $ B \mid \Pi x{::}S \sqsubset A. W $ \\
%            Worlds                  & $ W ::= $       & $ \langle \ell_i {::} S_i \sqsubset B_i \rangle_n \mid \Pi x{::}S \sqsubset A. W $ \\
            Schema                  & $ \Xi ::= $     & $ \varepsilon \mid \Xi + W $ \\
                                    &                 & \\
            Heads                   & $ H ::= $       & $ \textbf{c} \mid x \mid \proj \ k \ x \mid \Clo(x, s[\sigma]) \mid \#p[\sigma] \mid \proj \ k \ \#p $ \\
            Spines                  & $ \vec{M} ::= $ & $ \varepsilon \mid N ; \vec{M} $ \\
            Normal terms            & $ N ::= $       & $ R \mid \lambda x.N $\\
            Neutral terms           & $ R ::= $       & $ H \ \vec{M} \mid u[\sigma] $\\
                                    &                 & \\
            LF contexts             & $ \Psi ::= $    & $ \cdot \mid \Psi, x{::}S \sqsubset A \mid \Psi, x{:} (\textbf{w} \vec{M}) $ \\
            Substitutions           & $ \sigma ::= $  & $ \cdot \mid \wk_\psi \mid s[\sigma] \mid \sigma ; N $
        \end{tabular}
        \caption{Syntax of data-level}
        \label{fig:SyntaxData}
    \end{figure}

    \textbf{Note}.  $\sbbox$ expressions are not fully added yet.  In particular, they should also be a part of branches, but I still need to figure
    out the correct rule (it should be similar to the other rule for branches).

    The updated syntax of the language is given in Figure \ref{fig:SyntaxData}.  Most of the syntax that was already present in Beluga remains 
    unchanged (kinds, types, terms, and substitution, to be precise).  The main differences are in the contexts and signatures, where assumptions
    are endowed with a sort as well as a type.  Most importantly, LF contexts have an additional construct to associate variables to a given world,
    instead of just a type.  Finally, declarations are extended with subsorting and worlds.    

    In the syntax for sorts (and similarly for classes), $\top$ corresponds to all terms of the corresponding types, and $S_1 \land S_2$ is an intersection
    sort, so it classifies terms that can be classified by both $S_1$ and $S_2$.  

    In the syntax of worlds, records are denoted as $\langle \ell_i {::} S_i \sqsubset A_i \rangle_n$, where the subscript $n \geq 1$ indicates the 
    number of fields.  The $\Pi$'s in front of records can either be a parameter referred to by some of the fields, or assumptions needed to ensure
    the well-formedness of a given world.  Once we get to the sub-world judgment, we will see that using $\Pi$ is perhaps a bit misleading since the
    rules do not obey the familiar contravariance of $\Pi$-types.  So, we maybe we shouldn't think of them as functions, even though they seem like functions.

    Concerning the labels of worlds, I decided to take them out of the world's syntax itself, and rather consider them as names in declarations.  
    Ultimately, worlds should always be declared before they are used, so they would always be in the signature $\Sigma$.  This is just to avoid redundancy.

    \subsection{Judgments}
    As previously mentionned, most of the judgments take a slightly different form in the presence of refinements.  Let's first look at a 
    quick summary of the judgments :

    \begin{tabular}{ll}
        $ \vdash \Sigma \ \sig $                                       & Signature well-formedness \\
%        $ \vdash_\Sigma \Omega \ \sctx$                                 & Schema context well-formedness \\
        $ \vdash_\Sigma \Delta \ \mctx $                         & Meta-context well-formedness \\
        $  \Delta \vdash_\Sigma \Psi \ \ctx $                    & LF context well-formedness \\
        $  \Delta; \Psi \vdash_\Sigma L \sqsubset K $            & Class $L$ refines kind $K$ \\
        $  \Delta; \Psi \vdash_\Sigma Q \sqsubset P \Rar L $     & Atomic sort $Q$ synthesizes atomic type $P$ and class $L$ \\
        $  \Delta; \Psi \vdash_\Sigma S \sqsubset A \Lar \Sort $ & Sort $S$ refines type $A$ \\
        $  \Delta; \Psi \vdash_\Sigma N \Lar S \sqsubset A $     & Normal term $N$ checks against sort $S$ refining type $A$ \\
        $  \Delta; \Psi \vdash_\Sigma R \Rar S \sqsubset A $     & Neutral term $R$ synthesizes sort $S$ refining type $A$ \\
        $  \Delta; \Psi \vdash_\Sigma \sigma \Lar \Phi $         & Substitution $\sigma$ checks against LF context $\Phi$ \\
        $  \Delta; \Psi \vdash_\Sigma S_1 \leq S_2 \sqsubset A $ & $S_1$ is a sub-sort of $S_2$ as refinements of $A$ \\
        $  \Delta; \Psi \vdash_\Sigma W \ \world $               & $W$ is a well-formed world \\
        $  \Delta; \Psi \vdash_\Sigma \Xi \ \schema $            & $\Xi$ is a well-formed context schema \\
        $  \Delta; \Psi_1 \vdash_\Sigma \Psi_2 : \Xi $           & LF context $\Psi$ has schema $\Xi$ \\
        $  \Delta; \Psi \vdash_\Sigma W_1 \leq W_2 $             & $W_1$ is a sub-world of $W_2$\\
        $  \Delta; \Psi \vdash_\Sigma \Xi_1 \leq \Xi_2 $         & $\Xi_1$ is a sub-schema of $\Xi_2$
    \end{tabular}

    \textbf{Notes}. (1) There might be too many contexts in some of these judgments.  In particular, worlds and schemata should be closed, and the judgments
    for their well-formedness will only be used in signature formation, which requires all contexts to be empty.
    
    (2) It may be better to consider only LF contexts that have a schema rather than having a judgment for well-formed contexts and well-schemaed contexts.
    To achieve this, it would probably be necessary to enrich the notion of a context schema slightly.  In particular, we would need a schema that
    specify a particular sort/type for the right-most element(s) of the context since that is frequently used in mechanization.  The intuition for this
    comes from the fact that we usually don't consider terms that are not well-typed, or types that are not well-kinded, so it is odd to consider
    contexts that are not well-schemaed.  On the other hand, since contexts can have multiple schemata, we may want to consider the classifier 
    $\texttt{ctx}$ as analogous to types and schemata as analogous to sorts.  In this case, we could have a $\top$ schema to talk about arbitrary contexts,
    and merge the two judgments, just like we do for sorting/typing.

    Before presenting the rules defining each of these judgments, let us go over some conventions that will simplify notation.
    
    For all the judgments except signature validity, we omit the subscript $\Sigma$ since the signature is fixed throughout any derivation.
    In all judgments except for meta-context validity, we assume that $\Delta$ is well-formed, and similarly we assume that $\Psi$ is well-formed 
    in all the remaining judgments except LF context validity.  In practice, we would check that contexts are well-formed at the leaves of
    the proof trees.

    For the synthesis judgments (those with $\Rar$), the contexts, signatures and first object on the right of the turnstile
    are inputs, and the rest are outputs.  For instance, in $ \Delta; \Psi \vdash_\Sigma Q \sqsubset P \Rar L$, both $P$ and $L$ are outputs.
    For the remaining jugments, everything is considered an input.  In all judgments, we assume that every input is well-formed and in canonical form.
    To enforce this, we need to use hereditary substitutions.

    Finally, we assume that all names of constants and variables are unique.  Now, let's look at the inference rules.
    
    % Signature well-formedness
    $\boxed{\vdash \Sigma \ \sig}$
    
    \begin{align*}
        & \infer{\vdash \cdot \ \sig}{} &
        & \infer{\vdash \Sigma, \textbf{s}{::}L \sqsubset \textbf{a} {:}  K \ \sig}
          {
            \vdash \Sigma \ \sig
            &&
            \cdot ; \cdot ; \cdot \vdash_\Sigma L \sqsubset K
          }
    \end{align*}
    \begin{align*}
        & \infer{\vdash \Sigma, \textbf{c} {::} S \sqsubset A \ \sig}
          {
            \vdash \Sigma \ \sig
            &&
            \cdot ; \cdot ; \cdot \vdash_\Sigma S \sqsubset A \Lar \Sort
          } &
        & \infer{\vdash \Sigma, \textbf{s}_1 \leq \textbf{s}_2 \sqsubset \textbf{a}}
          {
            \vdash \Sigma \ \sig
            &&
            \textbf{s}_1 \sqsubset \textbf{a} {::} L \sqsubset K \in \Sigma
            &&
            \textbf{s}_2 \sqsubset \textbf{a} {::} L \sqsubset K \in \Sigma
          }
    \end{align*}
    \begin{align*}
        & \infer{\vdash \Sigma , \textbf{w} {:} W}
          {
            \vdash \Sigma \ \sig
            &&
            \cdot ; \cdot ; \cdot \vdash_\Sigma W \ \world
          } &
        & \infer{\vdash \Sigma , \boldsymbol{\xi} {:} \Xi}
          {
            \vdash \Sigma \ \sig
            &&
            \cdot ; \cdot ; \cdot \vdash_\Sigma \Xi \ \schema
          } &
    \end{align*}

    In the rules for signature formation, there is a notable change from what is shown in \cite{LovasPfenning2010}, namely that we don't have
    declarations of the form $\textbf{a} {:} K$ or $\textbf{c} : A$.  I think those are unnecessary since we can just replace them with declarations
    of the form $\top \sqsubset \textbf{a} {::} \top \sqsubset K$ and $\textbf{c} {::} \top \sqsubset A$, respectively.

    \textbf{Note}.  After giving it some thought, this wouldn't work since all our declarations must introduce names.  Nevertheless, we get a more
    uniform system by using $\top$ refinements in place of just kinds or types, so I would prefer to keep this approach and just add rules for
    these cases.


    % Meta-context well-formedness
    $\boxed{\vdash_\Sigma \Delta \ \mctx}$

    \begin{align*}
      & \infer{\vdash \cdot \ \mctx}{} &
      & \infer{\vdash \Delta, u{::} S[\Psi] \sqsubset A[\Psi]}
        {
          \vdash \Delta \ \mctx
          &&
          \Delta ; \Psi \vdash S \sqsubset A \Lar \Sort
        }
    \end{align*}
    \begin{align*}
      & \infer{\vdash \Delta, p{::} S[\Psi] \sqsubset A[\Psi]}
        {
          \vdash \Delta \ \mctx
          &&
          \Delta ; \Psi \vdash S \sqsubset A \Lar \Sort
        } &
      & \infer{\vdash \Delta, s{:} \Psi_1[\Psi_2]}
        {
          \vdash \Delta \ \mctx
          &&
          \Delta ; \Psi_2 \vdash \Psi_1 \ \ctx
        }
    \end{align*}
    \begin{align*}
      \infer{\vdash \Delta, \psi {:} \Xi \ \sctx}
            {
              \vdash \Delta \ \sctx
              &&
              \boldsymbol{\xi} {:} \Xi \in \Sigma
            }
    \end{align*}

    \textbf{Notes}. (1) I'm still unsure about the distinction between meta-variables ($u$) and parameter variables ($p$).  I think it's more about 
    the way they are used?  Specifically, $p$ should only be substituted with an ordinary variable.

    (2) In the rule for substitution variables, the premise $\Delta ; \Psi_2 \vdash \Psi_1 \ \ctx$ does not match the usual LF context well-formedness
    judgment, which is of the form $\Delta \vdash \Psi \ \ctx$ (i.e. without an LF context on the left side of the turnstile).  Maybe it should be
    a substitution judgment instead?  Otherwise, the context validity judgment could be generalized in a straightforward way. The only paper that 
    talks about substitution variables is \cite{Pientka2008}, but the context formation rules are not given there.

    % LF context well-formedness
    $\boxed{ \Delta \vdash_\Sigma \Psi \ \ctx}$

    \begin{align*}
      & \infer{\Delta \vdash \cdot \ \ctx}{} &
      & \infer{\Delta \vdash \Psi, x {::}S \sqsubset A \ \ctx}
        {
          \Delta \vdash \Psi \ \ctx
          &&
          \Delta ; \Psi \vdash S \sqsubset A \Lar \Sort
        }
    \end{align*}
    \begin{align*}
      \infer{\Delta \vdash \Psi, x{:} \textbf{w} \ \vec{M}}
            {
              \Delta \vdash \Psi \ \ctx
              &&
              \textbf{w} {:} \Pi (\overrightarrow{x{::}S \sqsubset A}).\langle \ell_i {::} S_i \sqsubset B_i \rangle_n \in \Sigma
              &&
              \Delta, \Psi \vdash \vec{M} \Lar \overrightarrow{S \sqsubset A}
            }
    \end{align*}

    \textbf{Remark}.  I've decided to use spines instead of substitutions for world parameters, mostly because users would want to refer to
    the terms during proofs, so that's what they would specify.

    % LF contexts relation
    $\boxed{\Delta \vdash_\Sigma \Psi_1 \leq \Psi_2}$

    \begin{align*}
      & \infer{\Delta \vdash \cdot \leq \cdot}{} &
      & \infer{\Delta \vdash (\Psi_1, x{::}S_1 \sqsubset A) \leq (\Psi_2, x{::}S_2)}
              {
                \Delta \vdash  \Psi_1 \leq \Psi_2
                &&
                \Delta; \Psi_2 \vdash S_1 \leq S_2 \sqsubset A
              }
    \end{align*}

    \textbf{Note}.  I'm not sure if we should have $\Delta; \Psi_1 \vdash S_1 \leq S_2 \sqsubset A$ as the premise (instead of the judgment with $\Psi_2$).
    In a subtyping rule, we would use the most precise type in the context, but here it is the least precise context that is used.

    % Kind refinements
    $\boxed{ \Delta; \Psi \vdash_\Sigma L \sqsubset K}$
    
    \begin{align*}
      & \infer{\Delta ; \Psi \vdash \Sort \sqsubset \Type}{} &
      & \infer{\Delta ; \Psi \vdash \Pi x{::}S.L \sqsubset \Pi x{:}A.K}
        {
          \Delta ; \Psi \vdash S \sqsubset A \Lar \Sort
          &&
          \Delta ; \Psi, x {:} S \sqsubset A \vdash L \sqsubset K
        }
    \end{align*}
    \begin{align*}
      & \infer{\Delta ; \Psi \vdash \top \sqsubset K}{} &
      & \infer{\Delta ; \Psi \vdash L_1 \land L_2 \sqsubset K}
        {
          \Delta ; \Psi  \vdash L_1 \sqsubset K
          &&
          \Delta ; \Psi  \vdash L_2 \sqsubset K
        }
    \end{align*}

    \textbf{Notes}. (1) For the rule with $\top$, we probably need a premise stating that $K$ is a well-formed kind, which implies that we need an extra
    judgment for kind validity (that would be exactly the same as what is already in Beluga).

    (2) Rules for \texttt{Rec} kinds are missing.

    % Class synthesis
    $\boxed{ \Delta; \Psi \vdash_\Sigma Q \sqsubset P \Rar L}$

    \begin{align*}
      & \infer{\Delta ; \Psi \vdash \textbf{s} \sqsubset \textbf{a} \Rar L}
        {
          \textbf{s} {::} L \sqsubset \textbf{a} {:} K \in \Sigma
        } &
      & \infer{\Delta; \Psi \vdash Q \ N \sqsubset P \ N \Rar [N/x]L}
        {
          \Delta ; \Psi \vdash Q \sqsubset P \Rar \Pi x{::}S. L
          &&
          \Delta ; \Psi \vdash N \Lar S \sqsubset A
        }
    \end{align*}
    \begin{align*}
      & \infer{\Delta ; \Psi \vdash Q \sqsubset P \Rar L_1}
        {
          \Delta ; \Psi \vdash Q \sqsubset P \Rar L_1 \land L_2
        } &
      & \infer{\Delta ; \Psi \vdash Q \sqsubset P \Rar L_2}
        {
          \Delta ; \Psi \vdash Q \sqsubset P \Rar L_1 \land L_2
        }
    \end{align*}

    % Class checking (only against Sort)
    $\boxed{\Delta ; \Psi \vdash_\Sigma S \sqsubset A \Lar \Sort}$

    \begin{align*}
      & \infer{\Delta; \Psi \vdash Q \sqsubset P \Lar \Sort}
        {
          \Delta; \Psi \vdash Q \sqsubset P \Rar \Sort
        } &
      & \infer{\Delta; \Psi \vdash \Pi x{::}S. S' \sqsubset \Pi x{:}A.A' \Lar \Sort}
        {
          \Delta; \Psi \vdash S \sqsubset A \Lar \Sort
          &&
          \Delta; \Psi, x{::}S \sqsubset A \vdash S' \sqsubset A'
        }
    \end{align*}
    \begin{align*}
      & \infer{\Delta; \Psi \vdash \top A \Lar \Sort}{} &
      & \infer{\Delta; \Psi \vdash S_1 \land S_2 \sqsubset A \Lar \Sort}
        {
          \Delta; \Psi \vdash S_1 \sqsubset A \Lar \Sort
          &&
          \Delta; \Psi \vdash S_2 \sqsubset A \Lar \Sort
        }
    \end{align*}

    \textbf{Note}.  Again, the rule for $\top$ should probably have a premise $\Delta; \Psi \vdash A \Lar \Type$, which requires adding
    a type well-formedness judgment.

    % Sort/type checking
    $\boxed{ \Delta; \Psi \vdash_\Sigma N \Lar S \sqsubset A}$

    \begin{align*}
      & \infer{\Delta; \Psi \vdash R \Lar S' \sqsubset A}
        {
          \Delta; \Psi \vdash R \Rar S \sqsubset A
          &&
          \Delta; \Psi \vdash S \leq S' \sqsubset A
        } &
      & \infer{\Delta; \Psi \vdash \lambda x.N \Lar \Pi x{::}S.S' \sqsubset \Pi x{:}A.A'}
        {
          \Delta; \Psi, x{::}S \sqsubset A \vdash N \Lar S' \sqsubset A'
        }
    \end{align*}
    \begin{align*}
      & \infer{\Delta; \Psi \vdash N \Lar S_1 \land S_2 \sqsubset A}
        {
          \Delta; \Psi \vdash N \Lar S_1 \sqsubset A
          &&
          \Delta; \Psi \vdash N \Lar S_2 \sqsubset A
        }
    \end{align*}

    % Sort/type synthesis
    $\boxed{ \Delta; \Psi \vdash_\Sigma R \Rar S \sqsubset A}$
    \begin{align*}
      & \infer{\Delta; \Psi \vdash \textbf{c} \Rar S \sqsubset A}
        {
          \textbf{c} {::} S \sqsubset A \in \Sigma
        } &
      & \infer{\Delta; \Psi \vdash x \Rar S \sqsubset A}
        {
          x {::} S \sqsubset A \in \Psi
        } 
    \end{align*}
    \begin{align*}
      \infer[(\text{for } 1 \leq k \leq n)]
            {\Delta; \Psi \vdash \proj \ k \ x \Rar [\ell_{k-1}; ..., \ell_1; \overleftarrow{M}]S_k \sqsubset [\ell_{k-1}; ..., \ell_1; \overleftarrow{M}] B_k}
            {
              x {:} \textbf{w} \ \vec{M} \in \Psi
              &&
              \textbf{w} {:} \Pi (\overrightarrow{y {::} S \sqsubset A}). \langle \ell_i {::} S_i \sqsubset B_i \rangle_n \in \Sigma
            }
    \end{align*}
    \begin{align*}
      \infer{\Delta; \Psi \vdash R \ N \Rar [N/x]S \sqsubset [N/x]A_2}
            {
              \Delta; \Psi \vdash R \Rar \Pi x{::}S_1 \sqsubset A_1. S_2 \sqsubset \Pi x{:}A_1. A_2
              &&
              \Delta; \Psi \vdash N \Lar S_1 \sqsubset A_1
            }
    \end{align*}
    \begin{align*}
      & \infer{\Delta; \Psi \vdash R \Rar S_1 \sqsubset A}
              {\Delta; \Psi \vdash R \Rar S_1 \land S_2 \sqsubset A} &
      & \infer{\Delta; \Psi \vdash R \Rar S_2 \sqsubset A}
              {\Delta; \Psi \vdash R \Rar S_1 \land S_2 \sqsubset A}
    \end{align*}
    
    \textbf{Remarks}. (1) In the rule for projections, $\overleftarrow{M}$ is just $\vec{M}$ backwards.  This is necessary since we construct spines
    from right to left, and substitutions from left to right.

    (2) Because of the last two rules regarding intersection sorts, the system is not deterministic.

    \textbf{Note}.  The rules for parameter variables, meta-variables, and closures are still missing.  

    % Substitutions
    $\boxed{ \Delta; \Psi_1 \vdash_\Sigma \sigma \Lar \Psi_2}$

    \begin{align*}
      & \infer{\Delta; \Psi_1 \vdash \cdot \Lar \cdot}{} &
      & \infer{\Delta; \Psi_1 \vdash s[\sigma] \Lar \Psi_2}
        {
          \Delta; \Psi_1 \vdash \sigma \Lar \Psi_2'
          &&
          s{::}\Psi_2[\Psi_2'] \in \Delta
        }
    \end{align*}
    \begin{align*}
      & \infer{\Delta; \psi, \Psi \vdash \wk_\psi \Lar \psi}{} &
      & \infer{\Delta; \Psi_1 \vdash (\sigma; N) \Lar (\Psi_2, x{::}S \sqsubset A)}
        {
          \Delta; \Psi_1 \vdash \sigma \Lar \Psi_2
          &&
          \Delta; \Psi_1 \vdash N \Lar S \sqsubset A
        }
    \end{align*}
    \begin{align*}
      \infer{\Delta; \Psi_1 \vdash (\sigma; B) \Lar (\Psi_2, x{:} \textbf{w} \ \vec{M})}
            {
              \Delta; \Psi \vdash \vec{M} \Lar \overrightarrow{S \sqsubset A}
              &&
              \Delta; \Psi, (\overrightarrow{x{::}S \sqsubset A}) \vdash B \ \block %\langle \ell_i {::} S_i \sqsubset B_i \rangle_n
            }
    \end{align*}

    \textbf{Notes}. (1) The rule for substitution of $x : \textbf{w} \ \vec{M}$ could be better.  In particular, the world's signature should appear
    in the premises to ensure well-formedness.

    (2) The rule for substitution variables could be enhanced with a context relation.  (Later, I'll ignore substitution variables for now)

    \textbf{Remark}.  The premise $\Delta; \Psi \vdash \overrightarrow{S \sqsubset A} \Lar \Sort$ checks that all the sorts are valid, given that 
    the previous ones are.  Formally, this auxilliary judgment is given by the following two rules :
    \begin{align*}
      & \infer{\Delta; \Psi \vdash S \sqsubset A ; \varepsilon \Lar \Sort}{ \Delta; \Psi \vdash S \sqsubset A \Lar \Sort} &
      & \infer{\Delta; \Psi \vdash S' \sqsubset A' ; \overrightarrow{S \sqsubset A} \Lar \Sort}
        {
          \Delta; \Psi \vdash \overrightarrow{S \sqsubset A} \Lar \Sort
          &&
          \Delta; \Psi, (\overrightarrow{x{::}S \sqsubset A}) \vdash S' \sqsubset A' \Lar \Sort
        }
    \end{align*}

    % Subsorting
    $\boxed{ \Delta; \Psi \vdash_\Sigma S_1 \leq S_2 \sqsubset A }$
    
    \begin{align*}
      & \infer{\Delta; \Psi \vdash S \leq S \sqsubset A}{\Delta; \Psi \vdash S \sqsubset A} &
      & \infer{\Delta; \Psi \vdash S_1 \leq S_3 \sqsubset A}
        {
          \Delta; \Psi \vdash S_1 \leq S_2 \sqsubset A
          &&
          \Delta; \Psi \vdash S_2 \leq S_3 \sqsubset A
        }
    \end{align*}
    \begin{align*}
      & \infer{\Delta; \Psi \vdash S \leq \top \sqsubset A}{\Delta; \Psi \vdash S \sqsubset A} &
      & \infer{\Delta; \Psi \vdash \Pi x{::}S_1. S_1' \leq \Pi x{::}S_2. S_2' \sqsubset \Pi x{:}A.A'}
        {
          \Delta; \Psi \vdash S_2 \leq S_1 \sqsubset A
          &&
          \Delta; \Psi \vdash S_1' \leq S_2' \sqsubset A'
        }
    \end{align*}
    \begin{align*}
      \infer{\Delta; \Psi \vdash S \leq S_1 \land S_2 \sqsubset A}
            { 
              \Delta; \Psi \vdash S \leq S_1 \sqsubset A
              &&
              \Delta; \Psi \vdash S \leq S_2 \sqsubset A
            }
    \end{align*}
    \begin{align*}
      & \infer{\Delta; \Psi \vdash S_1 \land S_2 \sqsubset A}
        { 
          \Delta; \Psi \vdash S_1 \leq S \sqsubset A
          &&
          \Delta; \Psi \vdash S_2 \sqsubset A \Lar \Sort
        } &
      & \infer{\Delta; \Psi \vdash S_1 \land S_2 \sqsubset A}
        { 
          \Delta; \Psi \vdash S_2 \leq S \sqsubset A
          &&
          \Delta; \Psi \vdash S_1 \sqsubset A \Lar \Sort
        }
    \end{align*}

    % Block well-formedness
    $\boxed{\Delta; \Psi \vdash_\Sigma B \ \block}$
    
    \begin{align*}
      & \infer{\Delta; \Psi \vdash (S \sqsubset A) \ \block}
              {
                \Delta; \Psi \vdash S \sqsubset A \Lar \Sort
              } &
      & \infer{\Delta; \Psi \vdash (\Sigma x{::}S \sqsubset A. B) \ \block}
              {
                \Delta; \Psi \vdash S \sqsubset A \Lar \Sort
                &&
                \Delta; \Psi, x{::} S \sqsubset A \vdash B \ \block
              }
    \end{align*}
    
    % World well-formedness    
    $\boxed{ \Delta; \Psi \vdash_\Sigma W \ \world}$

    \begin{align*}
      & \infer{\Delta; \Psi \vdash B \ \world}{\Delta; \Psi \vdash B \ \block} &
      & \infer{\Delta; \Psi \vdash (\Pi x{::}S \sqsubset A. W) \ \world}
              {
                \Delta; \Psi \vdash S \sqsubset A \Lar \Sort
                &&
                \Delta; \Psi, x{::} S \sqsubset A \vdash W \ \world
              }
    \end{align*}

    % Schema well-formedness
    $\boxed{ \Delta; \Psi \vdash_\Sigma \Xi \ \schema}$

    \begin{align*}
      & \infer{\Delta; \Psi \vdash \varepsilon \ \schema}{} &
      & \infer{\Delta; \Psi \vdash \Xi + \textbf{w} \ \schema}
        {
          \Delta; \Psi \vdash \Xi \ \schema
          &&
          \textbf{w} {:} W \in \Sigma
          &&
          \textbf{w} \notin \Xi
        }
    \end{align*}
    
    \textbf{Note}.  The judgments for world and schema validity and only used in signature formations, which requires the contexts to be empty.
    So, they may not be needed at all in this case.

    % Schemaing of LF contexts
    $\boxed{ \Delta \vdash_\Sigma \Psi : \Xi}$
    
    \begin{align*}
      & \infer{ \Delta \vdash \cdot {:} \varepsilon}{} &
      & \infer{ \Delta \vdash \psi {:} \Xi}{\psi {:} \Xi \in \Delta} &
      & \infer{ \Delta \vdash \Psi {:} \Xi_2}
        {
           \Delta \vdash \Psi {:} \Xi_1
          &&
           \Delta \vdash \Xi_1 \leq \Xi_2
        }
    \end{align*}
    \begin{align*}
      \infer{ \Delta \vdash (\Psi, x{:} \textbf{w} \ \vec{M}) : \Xi}
            {
               \Delta \vdash \Psi : \Xi
              &&
              \textbf{w} {:} \Pi \overrightarrow{x{::}S \sqsubset A}. \langle \ell_i {::} S_i \sqsubset B_i \rangle_n \in \Xi
              &&
              \Delta; \Psi \vdash \vec{M} \Lar \overrightarrow{S \sqsubset A}
            }
    \end{align*}

    \textbf{Note}. The judgment $ \Delta; \Psi \vdash \vec{M} \Lar \overrightarrow{S \sqsubset A}$ is just checking each of the terms in the 
    spine $\vec{M}$ against the corresponding type (which may depend on the previous terms).  Rules will be added soon.

    % Sub-blocks
    $\boxed{\Delta; \Psi \vdash_\Sigma B_1 \leq B_2}$
    \begin{align*}
      & \infer{\Delta; \Psi \vdash (S_1 \sqsubset A) \leq (S_2 \sqsubset A)}
              {
                \Delta; \Psi \vdash S_1 \leq S_2 \sqsubset A
              } &
      & \infer{\Delta; \Psi \vdash \Sigma x{::}S \sqsubset A. B_1 \leq B_2}
              {
                \Delta ; \Psi \vdash B_1 \leq B_2
                &&
                \Delta; \Psi \vdash S \sqsubset A \Lar \Sort
              }
    \end{align*}
    \begin{align*}
      \infer{\Delta; \Psi \vdash (\Sigma x{::} S_1 \sqsubset A).B_1 \leq (\Sigma x{::}S_2 \sqsubset A). B_2 }
            {
              \Delta; \Psi \vdash S_1 \leq S_2 \sqsubset A
              &&
              \Delta; \Psi, x{::}S_1 \sqsubset A \vdash B_1 \leq B_2
            }
    \end{align*}

    % Sub-worlds
    $\boxed{ \Delta; \Psi \vdash_\Sigma W_1 \leq W_2}$

    \begin{align*}
      & \infer{\Delta; \Psi \vdash B_1 \leq B_2 \quad (\text{as worlds})}
              {
                \Delta; \Psi \vdash B_1 \leq B_2 \quad ( \text{as blocks})
              } &
      & \infer{\Delta; \Psi \vdash \Pi x{::}S \sqsubset A. W_1 \leq W_2}
              {
                \Delta ; \Psi \vdash W_1 \leq W_2
                &&
                \Delta; \Psi \vdash S \sqsubset A \Lar \Sort
              }
    \end{align*}
    \begin{align*}
      \infer{\Delta; \Psi \vdash (\Pi x{::} S_1 \sqsubset A).W_1 \leq (\Pi x{::}S_2 \sqsubset A). W_2 }
            {
              \Delta; \Psi \vdash S_1 \leq S_2 \sqsubset A
              &&
              \Delta; \Psi, x{::}S_1 \sqsubset A \vdash W_1 \leq W_2
            }
    \end{align*}

    \textbf{Remark}.  We stress that the last rule for sub-worlds does not satisfy the usual contravariance associated to subtyping of $\Pi$-types, which
    indicates that we may not want to consider $\Pi$-worlds as functions.  In addition, we also have this rule stating that having extra parameters yields
    sub-worlds, which is also not the case when subtyping function spaces.
    
    % Sub-schema
    $\boxed{ \Delta; \Psi \vdash_\Sigma \Xi_1 \leq \Xi_2}$
    \begin{align*}
      & \infer{\Delta; \Psi \vdash \varepsilon \leq \Xi}{\Delta; \Psi \vdash \Xi \ \schema} &
      & \infer{\Delta; \Psi \vdash \Xi_1 + W_1 \leq \Xi_2 + W_2}
        {
          \Delta; \Psi \vdash \Xi_1 \leq \Xi_2
          &&
          \Delta; \Psi \vdash W_1 \leq W_2
        } &
      & \infer{\Delta; \Psi \vdash \Xi_1 + \Xi_2 \leq \Xi_2 + \Xi_1}{\Delta; \Psi \vdash \Xi_1 + \Xi_2 \ \schema}
    \end{align*}

    \section{Computation-level}
    We can lift the data-level refinements to the computation-level to obtain a restricted notion of refinements where the user does not directly
    specify any sorts.  It could be interesting to have a full blown refinement type system, and it should not complicate matters too much.

    \subsection{Syntax}
    \begin{figure}[tbh]
      \centering
      \begin{tabular}{rrl}
        Contexts                & $\Gamma ::=$ & $\cdot \mid \Gamma, y{::}\mu \sqsubset \kappa$ \\
                                &              & \\
        Kinds                   & $\kappa ::=$ & $\ctype \mid \Pi x{:}A[\Psi].\kappa$ \\
        Classes                 & $\zeta ::=$  & $\csort \mid \Pi x{::}S[\Psi]. \zeta \mid \top \mid \zeta_1 \land \zeta_2$ \\
                                &              & \\
        Types                   & $\tau ::=$   & $A[\Psi] \mid \tau_1 \rar \tau_2 \mid \Pi \psi{:}\Xi. \tau \mid \Pi^\square u{:}A[\Psi]. \tau$ \\
        Sorts                   & $\mu ::=$    & $S[\Psi] \mid \mu_1 \rar \mu_2 \mid \Pi \psi{:}\Xi.\mu \mid \Pi^\square u{::}S[\Psi].\mu 
                                                  \mid \top \mid \mu_1 \land \mu_2$ \\
                                &              & \\
        Checked expressions     & $e ::=$      & $i \mid \rec \ f.e \mid \fn \ y.e \mid \Lambda \psi. e \mid \lambda^\square u.e 
                                                  \mid \bbox(\hat{\Psi}.M) \mid \sbbox(\hat{\Psi}. \sigma) \mid \case \ i \ \of \ bs$ \\
        Synthesized expressions & $i ::=$      & $y \mid i \ e \mid i \ \lceil \Psi \rceil \mid i \ \lceil \hat{\Psi}. N \rceil 
                                                  \mid ( e{::} \mu \sqsubset \tau)$ \\
        Branch                  & $b ::=$      & $\Pi \Delta. \bbox(\Psi.M) {::} S[\Psi] \sqsubset A[\Psi] \mapsto e$ \\
        Branches                & $bs ::=$     & $\cdot \mid (b \mid bs)$
      \end{tabular}
      \caption{Syntax of computation level}
      \label{fig:SyntaxComp}
    \end{figure}

    The syntax for the computation level is given in Figure \ref{fig:SyntaxComp}.  Again, it is essentially the same as what is already in Beluga, except
    that we have sorts and classes.  However, in this case, we consider a restricted version that is fully induced by the refinements (and schemata) of
    the data level.

    \textbf{Notes}. (1) In practice, we allow user-defined computation-level type families, but they are not present in the current formulation.  To add
    them, we would need to extend the syntax for types and have addition declarations.  In this case, it wouldn't be much more work to add user-defined
    sorts.

    (2) For sorts, we may want to consider $\Pi^\square u{::}S[\Psi_1] \sqsubset A[\Psi_2]. \mu$ instead of having both LF contexts be identical, probably
    with the condition that $\Psi_1$ is contained in $\Psi_2$ (up to renaming).  In particular, we could have $\Psi_1 {:} \Xi_1$ and $\Psi_2 {:} \Xi_2$,
    where $\Xi_1 \leq \Xi_2$.

    (3) It may be better to have $\Pi x{:}A[\Psi].\kappa$ kinds, and similarly for classes.

    \subsection{Judgments}
    We have the follow computation level judgments :

    \begin{tabular}{ll}
      $ \Delta \vdash_\Sigma \Gamma \ \cctx$                                         & $\Gamma$ is a well-formed context \\
      $ \Delta; \Gamma \vdash_\Sigma \zeta \sqsubset \kappa$                       & Class $\zeta$ refines kind $\kappa$ \\
      $ \Delta; \Gamma \vdash_\Sigma \mu \sqsubset \tau \Lar \csort$               & Sort $\mu$ refines type $\tau$ \\
      $ \Delta; \Gamma \vdash_\Sigma e \Lar \mu \sqsubset \tau$                    & Expression $e$ checks agains sort $\mu$ refining type $\tau$ \\
      $ \Delta; \Gamma \vdash_\Sigma i \Rar \mu \sqsubset \tau$                    & Expression $i$ synthesizes saor $\mu$ refining type $\tau$ \\
      $ \Delta; \Gamma \vdash_\Sigma b \Lar_{\mu' \sqsubset \tau'} \mu \sqsubset \tau$ & Branch $b$ checks against $\mu$ refining $\tau$ 
                                                                                           when analyzing a $\mu'$ refining $\tau'$ \\
      $ \Delta; \Gamma \vdash_\Sigma \mu_1 \leq \mu_2 \sqsubset \tau$              & $\mu_1$ is a subsort of $\mu_2$ 
    \end{tabular}

    Again, we omit the subscript $\Sigma$ since it is fixed throughout any derivation, and we assume that all inputs are well-formed.  The system should
    be decidable if we follow the same input/output convention as in the data level (i.e. the synthesized sorts and types are outputs, and everything else
    is an input).  The judgments are defined via the following rules :

    \textbf{Notes.} (1) Just as in the data-level, it may be necessary to have judgments for kind and type well-formedness.

    (2) Since we are just lifting everything to the computation level, it may be redundant to have $\top$ and intersection computation-level sorts (and 
    classes) since they could probably always be inferred from $\top$ and intersection data-level sorts (and classes).

    (3) The rules for refinement should be enhanced with (LF) context relations

    % Context well-formedness
    $\boxed{ \Delta \vdash_\Sigma \Gamma \ \cctx}$
    
    \begin{align*}
      & \infer{ \Delta \vdash \cdot \ \cctx}{} &
      & \infer{ \Delta \vdash \Gamma, y{::}\mu \sqsubset \tau \ \cctx}
        {
           \Delta \vdash \Gamma \ \cctx
          &&
           \Delta; \Gamma \vdash \mu \sqsubset \tau \Lar \tau
        }
    \end{align*}

    % Class refining kinds
    $\boxed{ \Delta; \Gamma \vdash_\Sigma \zeta \sqsubset \kappa}$
    
    \begin{align*}
      & \infer{ \Delta; \Gamma \vdash \csort \sqsubset \ctype}{} &
      & \infer{ \Delta; \Gamma \vdash \top \sqsubset \kappa}{}
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash \Pi y{::}S[\Psi]. \zeta \sqsubset \Pi y{:}A[\Psi]. \kappa}
            {
               \Delta; \Psi \vdash S \sqsubset A
              &&
               \Delta; \Gamma, y{::}S[\Psi] \sqsubset A[\Psi] \vdash \zeta \sqsubset \kappa
            }
    \end{align*}    
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash \zeta_1 \land \zeta_2 \sqsubset \kappa}
            {
               \Delta; \Gamma \vdash \zeta_1 \sqsubset \kappa
              &&
               \Delta; \Gamma \vdash \zeta_2 \sqsubset \kappa
            }
    \end{align*}

    \textbf{Note}.  For the $\Pi$ rule, it indeed seems better to have the boxed LF contexts since we establish $S \sqsubset A$ at the data-level.

    % Sorts refining types
    $\boxed{ \Delta; \Gamma \vdash_\Sigma \mu \sqsubset \tau \Lar \csort}$

    \begin{align*}
      \infer{ \Delta; \Gamma \vdash S[\Psi] \sqsubset A[\Psi] \Lar \csort}
            { \Delta; \Psi \vdash S \sqsubset A \Lar \Sort}
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash \mu_1 \rar \mu_2 \sqsubset \tau_1 \rar \tau_2 \Lar \csort}
            {
               \Delta; \Gamma \vdash \mu_1 \sqsubset \tau_1 \Lar \csort
              &&
               \Delta; \Gamma, y{::}\mu_1 \sqsubset \tau_1 \vdash \mu_2 \sqsubset \tau_2 \Lar \csort
            }
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash \Pi^\square u{::} S[\Psi]. \mu \sqsubset \Pi^\square u{:}A[\Psi]. \tau \Lar \csort}
            {
               \Delta; \Psi \vdash S \sqsubset A \Lar \Sort
              &&
               \Delta, u{::}S[\Psi] \sqsubset A[\Psi]; \Gamma \vdash \mu \sqsubset \tau \Lar \csort
            }
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash\Pi \psi{:}\Xi_1 . \mu \sqsubset \Pi \psi{:}\Xi_2 . \tau \Lar \csort}
            {
               \Delta \vdash \Xi_1 \leq \Xi_2
              &&
              \Delta, \psi{:}\Xi_1; \Gamma \vdash \mu \sqsubset \tau
            }
    \end{align*}

    \textbf{Notes}. (1) Missing rules for $\top$ and intersection sorts.

    (2) It is not really necessary to mention $\csort$ everywhere in this judgment if we never check against other classes (although it's
    more likely that the other sorts are missing).

    % Expression sort/type-checking
    $\boxed{ \Delta; \Gamma \vdash_\Sigma e \Lar \mu \sqsubset \tau}$

    \begin{align*}
      & \infer{ \Delta; \Gamma \vdash i \Lar \mu' \sqsubset \tau}
        {
           \Delta; \Gamma \vdash i \Rar \mu \sqsubset \tau
          &&
           \Delta; \Gamma \vdash \mu \leq \mu' \sqsubset \tau
        } 
    \end{align*}
    \begin{align*}
      & \infer{ \Delta; \Gamma \vdash \bbox(\hat{\Psi}. M) \Lar S[\Psi] \sqsubset A[\Psi]}
            {
              \Delta; \Psi \vdash M \Lar S \sqsubset A
            } &
      & \infer{\Delta; \Gamma \vdash \sbbox(\hat{\Psi}. \sigma) \Lar \Psi'[\Psi]}
            {
              \Delta; \Psi \vdash \sigma \Lar \Psi'
            }
    \end{align*}q
    \begin{align*}
      & \infer{ \Delta; \Gamma \vdash \rec \ f.e \Lar \mu \sqsubset \tau}
        {
           \Delta; \Gamma, f{::}\mu \sqsubset \tau \vdash e \Lar \mu \sqsubset \tau
        } &
      & \infer{ \Delta; \Gamma \vdash \fn \ y.e \Lar \mu_1 \rar \mu_2 \sqsubset \tau_1 \rar \tau_2}
        {
           \Delta; \Gamma, y{::}\mu_1 \sqsubset \tau_1 \vdash e \Lar \mu_2 \sqsubset \tau_2
        }
    \end{align*}
    \begin{align*}
      & \infer{ \Delta; \Gamma \vdash \lambda^\square u.e \Lar \Pi^\square u{::}S[\Psi].\mu \sqsubset \Pi^\square u{:}A[\Psi]. \tau}
        {
           \Delta, u{::}S[\Psi] \sqsubset A[\Psi]; \Gamma \vdash e \Lar \mu \sqsubset \tau
        }
      & \infer{ \Delta; \Gamma \vdash \Lambda \psi. e \Lar \Pi \psi{:}\Xi.\mu \sqsubset \Pi \psi {:} \Xi. \tau}
        {
          \Delta, \psi{:}\Xi; \Gamma \vdash e \Lar \mu \sqsubset \tau
        }
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash \case \ i \ \of \ b_1 \mid ... \mid b_n \Lar \mu \sqsubset \tau}
            {
               \Delta; \Gamma \vdash i \Rar A[\Psi]
              &&
              \text{for all } k \  \Delta; \Gamma \vdash b_k \Lar_{S[\Psi] \sqsubset A[\Psi]} \mu \sqsubset \tau
            }
    \end{align*}

    \textbf{Note}.  The rule for $\sbbox$ terms has a slightly different form since there isn't a clear notion of refinements for contexts.  This
    reinforces the idea that there should be such a notion, since it makes a lot more sense to have all the checked expressions in the same judgment.

    % Expression sort/type synthesis
    $\boxed{ \Delta; \Gamma \vdash_\Sigma i \Rar \mu \sqsubset \tau}$
    
    \begin{align*}
      & \infer{\Delta; \Gamma \vdash (e {::} \mu \sqsubset \tau) \Rar \mu \sqsubset \tau}
        {
          \Delta; \Gamma \vdash e \Lar \mu \sqsubset \tau
        } &
      & \infer{ \Delta; \Gamma \vdash y \Rar \mu \sqsubset \tau}{y{::}\mu \sqsubset \tau \in \Gamma}
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash i \ e \Rar \mu_2 \sqsubset \tau_2}
            {
               \Delta; \Gamma \vdash i \Rar \mu_1 \rar \mu_2 \sqsubset \tau_1 \rar \tau_2
              &&
               \Delta; \Gamma \vdash e \Lar \mu_1 \sqsubset \tau_1
            }
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash i \ \lceil \Psi \rceil \Rar \llbracket \Psi/\psi \rrbracket (\mu \sqsubset \tau)}
            {
               \Delta; \Gamma \vdash i \Rar \Pi \psi{:}\Xi_1. \mu \sqsubset \Pi \psi{:}\Xi_2. \tau
              &&
               \Delta; \Gamma \vdash \Psi : \Xi_1
            }
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash i \ \lceil \Psi. M \rceil \Rar \llbracket \Psi. M / u \rrbracket (\mu \sqsubset \tau)}
            {
               \Delta; \Gamma \vdash i \Rar \Pi^\square u{::}S[\Psi]. \mu \sqsubset \Pi^\square u{:}A[\Psi]. \tau
              &&
               \Delta; \Psi \vdash M \Lar S \sqsubset A
            }
    \end{align*}

    % Branch sorting/typing
    $\boxed{ \Delta; \Gamma \vdash_\Sigma b \Lar_{\mu' \sqsubset \tau'} \mu \sqsubset \tau}$

    \begin{align*}
      \infer{ \Delta; \Gamma \vdash \Pi \Delta_k . \bbox(\Psi. M_k) : S_k[\Psi_k]  \sqsubset A_k[\Psi_k] \mapsto e_k 
                                                \Lar_{S[\Psi] \sqsubset A[\Psi]} \mu \sqsubset \tau}
            {
               \Delta; \Gamma \vdash M_k \Lar S_k \sqsubset A_k
              &&
              \begin{array}{ll}
                 \Delta, \Delta_k & \vdash \Psi \doteq \Psi_k / (\theta_1, \Delta') \\
                 \Delta'          & \vdash \llbracket \theta_1 \rrbracket ( S \sqsubset A) \doteq 
                                                  \llbracket \theta_1 \rrbracket(S_k \sqsubset A_k)/(\theta_2, \Delta'') \\
                 \Delta'';\llbracket \theta_2 \rrbracket \llbracket \theta_1 \rrbracket \Gamma & \vdash
                                        \llbracket \theta_2 \rrbracket \llbracket \theta_1 \rrbracket e_k 
                                        \Lar \llbracket \theta_2 \rrbracket \llbracket \theta_1 \rrbracket (\mu \sqsubset \tau)
              \end{array}
            }
    \end{align*}

    % Subsorting
    $\boxed{ \Delta; \Gamma \vdash_\Sigma \mu_1 \leq \mu_2 \sqsubset \tau}$
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash S[\Psi] \sqsubset A[\Psi]}
            {
               \Delta; \Psi \vdash S \sqsubset A
            }
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash\mu_1 \rar \mu_1' \leq \mu_2 \rar \mu_2' \sqsubset \tau \rar \tau'}
            {
               \Delta; \Gamma \vdash \mu_2 \leq \mu_1 \sqsubset \tau
              &&
               \Delta; \Gamma, y{::} \mu_2 \sqsubset \tau \vdash \mu_1' \leq \mu_2' \sqsubset \tau'
            }
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash\Pi^\square u{::}S_1[\Psi]. \mu_1 \leq \Pi^\square u{::}S_2[\Psi]. \mu_2 \sqsubset \Pi^\square u{:} A[\Psi]. \tau}
            {
               \Delta; \Psi \vdash S_2 \leq S_1 \sqsubset A
              &&
               \Delta, u{::} S_2[\Psi] \sqsubset A[\Psi]; \Gamma \vdash \mu_1 \leq \mu_2 \sqsubset \tau
            }
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash \Pi \psi{:}\Xi_1. \mu_1 \leq \psi{:}\Xi_2. \mu_2 \sqsubset \Pi \psi{:}\Xi. \tau}
            {
               \Delta \vdash \Xi_1 \leq \Xi_2
              &&
               \Delta \vdash \Xi_2 \leq \Xi
              &&
              \Delta,\psi{:}\Xi_1; \Gamma \vdash \mu_1 \leq \mu_2 \sqsubset \tau
            }
    \end{align*}

    \section{Operational Semantics}

    Next, we define a small-step operational semantics for the computational level\footnote{The data level only allows terms that are already in normal form,
    so there isn't any suitable notion of evaluation there.}, and we show that it satisfies type safety.

    The sort/type annotations in terms of the form $(e :: \mu \sqsubset \tau)$ are irrelevant to the evaluation algorithm, and can therefore be erased.  
    However, due the presence of dependent types in the language, we need to annotate branches with their sort/type.  This is important as we need to 
    perform pattern unification in order to determine which branch must be taken when stepping a $\case$ expression, which requires unifying the sort/type 
    of the guard with the sort/type of the pattern.  So, we need an annotation erasure algorithm, denoted $|e|$ and $|i|$ for checked and synthesized 
    expressions, respectively.  A simple way to do this is to follow the sorting derivation and annotate each subterm of sort $S[\Psi] \sqsubset A[\Psi]$ with
    its sort/type information, while removing all the annotations of the form $(e :: \mu \sqsubset \tau)$ \cite{PientkaDunfield2008}.

    Now, the values of our language are the following :
    
    \begin{center}
      \begin{tabular}{rrl}
        Values & $v ::=$ & $\fn y.e \mid \Lambda \psi.e \mid \bbox(\hat{\Psi}. M) \mid \sbbox(\hat{\Psi}. \sigma)$
      \end{tabular}
    \end{center}

    And our small-step semantics is given the following three judgments : 

    \begin{center}
      \begin{tabular}{ll}
        $e \rar e'$                                    & $e$ evaluates to $e'$ in one step \\
        $(\bbox(\hat{\Psi}.M) \doteq b) \rar e'$       & branch $b$ matches $\bbox(\hat{\Psi}.M)$ and steps to $e'$ \\
        $(\sbbox(\hat{\Psi}.\sigma) \doteq b) \rar e'$ & branch $b$ matches $\sbbox(\hat{\Psi}.\sigma)$ and steps to $e'$
      \end{tabular}
    \end{center}

    Which are defined by the following rules :

    $\boxed{e \rar e'}$

    \begin{align*}
      & \infer{\rec \ f.e \rar [\rec \ f.e / f] e}{} &
      & \infer{(\fn \ y. e) \ v \rar [v/y] e}{}
    \end{align*}
    \begin{align*}
      & \infer{(e_1 \ e_2) \rar (e_1' \ e_2)}{e_1 \rar e_1'} &
      & \infer{(e_1 \ e_2) \rar (e_1 \ e_2')}{e_2 \rar e_2'}
    \end{align*}
    \begin{align*}
      & \infer{(\Lambda \psi. e) \ \lceil \Psi \rceil \rar \llbracket \Psi / \psi \rrbracket e}{} &
      & \infer{(e \ \lceil \Psi \rceil) \rar (e' \ \lceil \Psi \rceil)}{e \rar e'}
    \end{align*}
    \begin{align*}
      & \infer{(\case \ \bbox(\hat{\Psi}. M) \ \of \ b_1 \mid ... \mid b_n) \rar e'}
              {\cdot ; \cdot \vdash ( \bbox(\hat{\Psi}.M) \doteq b_i) \rar e'} &
      & \infer{(\case \ \sbbox(\hat{\Psi}. \sigma) \ \of \ b_1 \mid ... \mid b_n) \rar e'}
              {\cdot ; \cdot \vdash ( \sbbox(\hat{\Psi}.\sigma) \doteq b_i) \rar e'}
    \end{align*}
    \begin{align*}
      \infer{\case \ i \ \of \ bs \rar \case i' \ \of \ bs}{i \rar i'}
    \end{align*}

    $\boxed{(\bbox(\hat{\Psi}.M) \doteq b) \rar e'}$

    \begin{align*}
      \infer{(\bbox(\hat{\Psi}.M) \doteq \Pi \Delta. \bbox(\hat{\Psi}. M') \mapsto e) \rar \llbracket \theta \rrbracket e}
            {
              \Delta; \Psi \vdash M' \doteq M / \theta
            }
    \end{align*}

    $\boxed{(\sbbox(\hat{\Psi}.\sigma) \doteq b) \rar e'}$

    \begin{align*}
      \infer{(\sbbox(\hat{\Psi}.\sigma) \doteq \Pi \Delta. \sbbox(\hat{\Psi}. \sigma') \mapsto e) \rar \llbracket \theta \rrbracket e}
            {
              \Delta; \Psi \vdash \sigma' \doteq \sigma / \theta
            }
    \end{align*}

    \textbf{Note}.  This is the second place where higher-order pattern unification is used, and I still haven't really figured out how it works.

    In order to guarantee that a well-sorted $\case$ expression steps, we need to ensure that one of the patterns matches the guard.  Therefore, in order
    to prove type safety, we first need a coverage checking algorithm.  For now, let's assume that the algorithm shown in \cite{DunfieldPientka2008} can 
    be adapated to our language with refinements.  

    An other key ingredient in the proof of type safety are substitution principles.  These principles are known to hold when refinements are not present 
    in the language \cite{PientkaDunfield2008, Nanevski2008}, and \cite{LovasPfenning2010} discusses them for LF with refinement, although there is no notion
    of contextual substitution in their work.  So, it can be expected that the principles will indeed hold in our language.  For now, we assume that this 
    is the case.

    The only thing missing before we can prove type safety is a canonical forms lemma :

    \begin{lemma}[Canonical Forms]
      \leavevmode
      \begin{enumerate}
        \item If $i$ is a value and $\cdot ; \cdot \vdash i \Rar \mu \rar \mu' \sqsubset \tau \rar \tau'$, then $|i| = \fn \ y.|e'|$ and
          $\cdot; y{::}\mu \sqsubset \tau \vdash e' \Lar \mu' \sqsubset \tau'$.

        \item If $i$ is a value and $\cdot; \cdot \vdash i \Rar \Pi^\square u {::} S[\Psi]. \mu \sqsubset \Pi^\square u{:}A[\Psi]. \tau$, then 
          $|i| = \lambda^\square u. |e'|$ and $u{::}S[\Psi] \sqsubset A[\Psi] ; \cdot \vdash e' \Lar \mu \sqsubset \tau$.

        \item If $i$ is a value and $\cdot ; \cdot \vdash i \Rar \Pi \psi{:}\Xi. \mu \sqsubset \Pi \psi{:}\Xi. \tau$, then $|i| = \Lambda \psi. |e'|$ and
          $\psi{:}\Xi ; \cdot \vdash e' \Lar \mu \sqsubset \tau$.

        \item If $i$ is a value and $\cdot ; \cdot \vdash i \Rar S[\Psi] \sqsubset A[\Psi]$, then $|i| = \bbox(\hat{\Psi}. M) :: S[\Psi] \sqsubset A[\Psi]$ 
          and $\cdot ; \Psi \vdash M \Lar S \sqsubset A$.

        \item If $i$ is a value and $\cdot ; \cdot \vdash i \Rar \Psi'[\Psi]$, then $|i| = \sbbox(\hat{\Psi}. \sigma) :: \Psi'[\Psi]$ and 
          $\cdot; \Psi \vdash \sigma \Lar \Psi'$.
      \end{enumerate}

      \begin{proof}
        
      \end{proof}
    \end{lemma}

    \textbf{Note}.  The statement of the lemma is a little weird.  None of our values can be synthesized except via the type annotation rule, so we are 
    really looking at checked expressions.  However, we need synthesized expressions to solve the case where the switch rule is used, as otherwise we 
    don't have an inductive hypothesis.  In addition, we assume that $i$, but immediately conclude that $i$ is of the form $(e :: \mu \sqsubset \tau)$, 
    which isn't really a value (the value would be $e$ in this case).  So, is it $|i|$ that is a value?

    And finally, we reach the target result of this section :

    \begin{theorem}[Type Safety]
      \leavevmode
      \begin{enumerate}
        \item If $\cdot; \cdot \vdash e \Lar \mu \sqsubset \tau$ and $e$ coverage checks, then either $|e|$ is a value. or there is some $e'$ such that 
          $|e| \rar |e'|$ and $\cdot ; \cdot \vdash e' \Lar \mu \sqsubset \tau$.

        \item If $\cdot; \cdot \vdash i \Rar \mu \sqsubset \tau$ and $i$ coverage checks, then either $|i|$ is a value. or there is some $i'$ such that 
          $|i| \rar |i'|$ and $\cdot ; \cdot \vdash i' \Rar \mu \sqsubset \tau$.
      \end{enumerate}
      
      \begin{proof}
        By simultaneous induction on the hypothesized derivation $\D$.
        \begin{enumerate}
          \item There are several cases to consider.  Consider first the following five rules :
            
            \begin{align*}
              & \infer{\cdot; \cdot \vdash \bbox(\hat{\Psi}.M) \Lar S[\Psi] \sqsubset A[\Psi]}
                      {\cdot; \Psi \vdash M \Lar S \sqsubset A} &
              & \infer{\cdot ; \cdot \vdash \sbbox(\hat{\Psi}. \sigma) \Lar \Psi'[\Psi]}
                        {\cdot; \Psi \vdash \sigma \Lar \Psi'} \\
              & \infer{\cdot ; \cdot \vdash \fn \ y.e \Lar \mu_1 \rar \mu_2 \sqsubset \tau_1 \rar \tau_2}
                      { \cdot; y{::}\mu_1 \sqsubset \tau_1 \vdash e \Lar \mu_2 \sqsubset \tau_2} &
              & \infer{\cdot; \cdot \vdash \lambda^\square u.e \Lar \Pi^\square u{::}S[\Psi]. \mu \sqsubset \Pi^\square u{:}A[\Psi].\tau}
                      {u{::}S[\Psi] \sqsubset A[\Psi] ; \cdot \vdash e \Lar \mu \sqsubset \tau}
            \end{align*}
            \begin{align*}
              \infer{\cdot; \cdot \vdash \Lambda \psi. e \Lar \Pi \psi{:} \Xi. \mu \sqsubset \Pi \psi{:}\Xi. \tau}
                    {\psi {:} \Xi ; \cdot \vdash e \Lar \mu \sqsubset \tau}
            \end{align*}
            
            In each of the above rules, the resulting term is already a value, so there is nothing more to do.  This leaves us with three other cases :

            \begin{description}
              \item[] \textbf{Case} $\D :: \infer{\cdot ; \cdot \vdash i \Lar \mu \sqsubset \tau}
                {
                  \begin{array}{c}
                    \D_1 \\
                    \cdot ; \cdot \vdash i \Rar \mu' \sqsubset \mu
                  \end{array}
                  &&
                  \begin{array}{c}
                    \D_2
                    \cdot ; \cdot \vdash \mu' \leq \mu \sqsubset \tau
                  \end{array}
                }$
                
                Either $i$ is a value, or $|i| \rar |i'|$ and $\cdot; \cdot \vdash i' \Rar \mu' \sqsubset \tau$, by inductive hypothesis on $\D_1$. \\
                If $i$ is a value, then there is nothing more to do. \\
                If $|i| \rar |i'|$ and $\D' :: \cdot; \cdot \vdash i' \Rar \mu' \sqsubset \tau$, then we obtain $\cdot ; \cdot \vdash i' \Lar \mu \sqsubset \tau$ 
                by using the switch rule with $\D'$ and $\D_2$. \\

              \item[] \textbf{Case} $\D :: \infer{\cdot; \cdot \vdash \rec \ f.e \Lar \mu \sqsubset \tau}
                {\cdot; f {::}\mu \sqsubset \tau \vdash e \Lar \mu \sqsubset \tau}$

                We have $\cdot; \cdot \vdash \rec \ f.e \Lar \mu \sqsubset \tau$ and $\cdot; f {::} \mu \sqsubset \tau \vdash e \Lar \mu \sqsubset \tau$ 
                by assumption. \\
                Then $\cdot; \cdot \vdash [\rec \ f.e / f] e \Lar \mu \sqsubset \tau$ by the substitution principle. \\
                This is what we wanted to show since $\rec \ f.e \rar [\rec \ f.e / f] e$ by definition of the stepping relation. \\

              \item[] \textbf{Case} $ \D :: \infer{\cdot ; \cdot \vdash \case \ i \ \of \ b_1 \mid ... \mid b_n \Lar \mu \sqsubset \tau}
                {
                  \begin{array}{c}
                    \D_0 \\
                    \cdot ; \cdot \vdash i \Rar S[\Psi] \sqsubset A[\Psi]
                  \end{array}
                  &&
                  \begin{array}{c}
                    \D_k \\
                    \text{for all k, } \cdot ; \cdot \vdash b_k \Lar_{S[\Psi] \sqsubset A[\Psi]} \mu \sqsubset \tau
                  \end{array}
                }$

                TODO.  Missing a lemma : If $\cdot; \cdot \vdash i \Rar S[\Psi] \sqsubset A[\Psi]$, and 
                $\cdot; \cdot \vdash b \Lar_{S[\Psi] \sqsubset A[\Psi]} \mu \sqsubset \tau$, and $ (i \doteq b) \rar e$, then 
                $\cdot; \cdot \vdash e \Lar \mu \sqsubset \tau$.
            \end{description}
            
          \item We again have a few cases to consider :
           
            \begin{description}
              \item[] \textbf{Case} $\D :: \infer{\cdot ; \cdot \vdash (e {::} \mu \sqsubset \tau) \Rar \mu \sqsubset \tau}
                {
                  \begin{array}{c}
                    \D' \\
                    \cdot ; \cdot \vdash e \Lar \mu \sqsubset \tau
                  \end{array}
                }$

                Either $e$ is a value, or $|e| \rar |e'|$ and $\cdot; \cdot \vdash e' \Lar \mu \sqsubset \tau$, by inductive hypothesis on $\D'$. \\
                This is what we wanted since $|(e {::} \mu \sqsubset \tau)| = |e|$.

              \item[] \textbf{Case} $\D :: \infer{\cdot; \cdot \vdash i \ e \Rar \mu_2 \sqsubset \tau_2}
                {
                  \begin{array}{c}
                    \D_1 \\
                    \cdot; \cdot \vdash i \Rar \mu_1 \rar \mu_2 \sqsubset \tau_1 \rar \tau_2
                  \end{array}
                  &&
                  \begin{array}{c}
                    \D_2 \\
                    \cdot; \cdot \vdash e \Lar \mu_1 \sqsubset \tau_1
                  \end{array}
                }$

                Either $|i|$ is a value, or $|i| \rar |i'|$ and $\cdot; \cdot \vdash i' \Rar \mu_1 \rar \mu_2 \sqsubset \tau_1 \rar \tau_2$, by 
                inductive hypothesis on $\D_1$.  \\
                Either $|e|$ is a value, or $|e| \rar |e'|$ and $\cdot; \cdot \vdash e' \Lar \mu_1 \sqsubset \tau_1$, by inductive hypothesis on $\D_2$. \\
                This gives us three sub-cases to consider :
                \begin{description}
                  \item[] \textbf{Sub-case} $|i| \rar |i'|$ and $\cdot ; \cdot \vdash i' \Rar \mu_1 \rar \mu_2 \sqsubset \tau_1 \rar \tau_2$

                    We have $|i \ e| \rar |i' \ e|$ by definition of the stepping relation. \\
                    And we obtain $\cdot; \cdot \vdash i' \ e \Rar \mu_2 \sqsubset \tau_2$ via the same rule that $\D$ ends with.

                  \item[] \textbf{Sub-case} $|e| \rar |e'|$ and $\cdot; \cdot \vdash e' \Lar \mu_1 \sqsubset \tau_1$
                    
                    We have $|i \ e| \rar |i \ e'|$ by definition of the stepping relation. \\
                    And we obtain $\cdot; \cdot \vdash i \ e' \Rar \mu_2 \sqsubset \tau_2$ via the same rule that $\D$ ends with.

                  \item[] \textbf{Sub-case} Both $|i|$ and $|e|$ are values

                    Then $|i| = \fn \ y. |e'|$ and $\cdot; y{::} \mu_1 \sqsubset \tau_1 \vdash e' \Lar \mu_2 \sqsubset \tau_2$ by the canonical forms lemma. \\
                    We have $(\fn \ y. |e'|) \ |e| \rar [e/y] e'$ by definition of the stepping relation. \\
                    And we have $\cdot; \cdot \vdash [e/y] e' \Lar \mu_2 \sqsubset \tau_2$ by the substitution principle.
                \end{description}

              \item[] \textbf{Case} $\D :: \infer{\cdot; \cdot \vdash i \ \lceil\hat{\Psi}. M\rceil 
                                                                              \Rar \llbracket \hat{\Psi}.M / y \rrbracket (\mu \sqsubset \tau)}
                {
                  \begin{array}{c}
                    \D_1 \\
                    \cdot; \cdot \vdash i \Rar \Pi^\square u{::}S[\Psi].\mu \sqsubset \Pi^\square u{:}A[\Psi]. \tau
                  \end{array}
                  &&
                  \begin{array}{c}
                    \phantom{\D_2} \\
                    \cdot; \Psi \vdash M \Lar S \sqsubset A
                  \end{array}
                }$

                Either $|i|$ is a value, or $|i| \rar |i'|$ and $\cdot; \cdot \vdash i' \Rar \Pi^\square u{::}S[\Psi].\mu \sqsubset \Pi^\square u{:}A[\Psi]. \tau$, 
                by inductive hypothesis on $\D_1$. \\
                This gives us two sub-cases :
                \begin{description}
                  \item[] \textbf{Sub-case} $|i|$ is a value

                    Then $|i| = \lambda^\square u. |e'|$ and $u{::}S[\Psi] \sqsubset A[\Psi] ; \cdot \vdash e \Lar \mu \sqsubset \tau$, by the canonical 
                    forms lemma. \\
                    We have $(\lambda^\square u. |e'|) \ \lceil \hat{\Psi}. M \rceil \rar \llbracket \hat{\Psi}.M / u \rrbracket e$ by definition of the
                    stepping relation. \\
                    And we have $\cdot; \cdot \vdash \llbracket \hat{\Psi}.M / u \rrbracket e \Lar \llbracket \hat{\Psi}.M / u \rrbracket ( \mu \sqsubset \tau)$
                    by the substitution principle.

                  \item[] \textbf{Sub-case} $|i| \rar |i'|$ and $\cdot; \cdot \vdash i' \Rar \Pi^\square u{::}S[\Psi].\mu \sqsubset \Pi^\square u{:}A[\Psi]. \tau$

                    We have $|i \ \lceil \hat{\Psi}. M \rceil| \rar |i' \ \lceil \hat{\Psi}. M \rceil|$, by definition of the stepping relation. \\
                    And we obtain $\cdot; \cdot \vdash i' \ \lceil \hat{\Psi}. M \rceil \Rar \mu \sqsubset \tau$ via the same that $\D$ ends with.
                \end{description}

              \item[] \textbf{Case} $\D :: \infer{\cdot; \cdot \vdash i \ \lceil \Psi \rceil \Rar \llbracket \Psi / \psi \llbracket (\mu \sqsubset \tau)}
                {
                  \begin{array}{c}
                    \D_1 \\
                    \cdot; \cdot \vdash i \Rar \Pi \psi {:} \Xi. \mu \sqsubset \Pi \psi{:}\Xi. \tau
                  \end{array}
                  &&
                  \begin{array}{c}
                    \D_2 \\
                    \cdot; \cdot \vdash \Psi : \Xi
                  \end{array}
                }$

                Similar to the previous case.

            \end{description}
        \end{enumerate}
      \end{proof}
    \end{theorem}

    \bibliographystyle{acm}
    \bibliography{bibliography}    
\end{document}
