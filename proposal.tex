\documentclass[letterpaper, 11pt]{article}

\usepackage{amsmath, amssymb, amsfonts}%math
\usepackage{mathtools}
\usepackage[left=2cm,right=2cm,top=2.75cm,bottom=2.75cm]{geometry}%margins
\usepackage[utf8x]{inputenc}%ASCII characters
\usepackage[T1]{fontenc}
\usepackage{lmodern}%for accentuated characters and accents
\usepackage{graphicx}%inserting pdf-jpg pictures
\usepackage[natural, dvipsnames, pdftex]{xcolor}
\usepackage{tikz} %Drawing pretty pictures
\usepackage{verbatim} %adding code
\usepackage[pdftex,  colorlinks=true]{hyperref}%Hyperlinks, with \href
\hypersetup{urlcolor=RoyalBlue,  linkcolor=RedOrange,  citecolor=black}

\usepackage{proof} %for proof trees
\usepackage{mathdots}

\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{n} %mathpzc alphabet
\usepackage[mathscr]{eucal} %mathscr alphabet

\usepackage{stmaryrd} %Bold brackets (for meta-substitutions)

%Redefine theorem environments
\usepackage[amsmath,  thref,  thmmarks,  hyperref]{ntheorem}


%Redefining theorem style
\theoremheaderfont{\bf}
\theorembodyfont{\normalfont}

\newtheorem*{theorem}{Theorem}[section]
\newtheorem*{lemma}[subsection]{Lemma}
\newtheorem{cor}[subsection]{Corollary}
\newtheorem{prop}[subsection]{Proposition}
\newtheorem*{claim}{Claim}
\newtheorem*{sol}{Solution}
\newtheorem{defn}[theorem]{Definition}
\newtheorem{ex}{Example}[section]
\newtheorem*{remark}{Remark}[section]
\newtheorem*{obs}{Observation}[section]
\newtheorem*{note}{Note}[section]
\renewcommand{\Box}{\rule{1.5ex}{1.5ex}}  % end of proof


\newenvironment*{proof}{\par\noindent{\normalfont{\bf{Proof. \\ \hphantom{mm}
}}}}{\hfill \small$\blacksquare$\\[-4pt]}


\usepackage{verbments}%fancy verbatim
\usepackage[shortlabels]{enumitem}

\newcommand{\mlcomment}[1]{} % multi-line comments (not great since it still processes the argument)

% Symbols
\newcommand{\Rar}{\Rightarrow}
\newcommand{\Lar}{\Leftarrow}
\newcommand{\rar}{\rightarrow}


%% keywords
% Syntax
\newcommand{\Type}{\texttt{Type}}
\newcommand{\Rec}{\texttt{Rec}}
\newcommand{\Sort}{\texttt{Sort}}
\newcommand{\wk}{\texttt{wk}}
\newcommand{\proj}{\texttt{proj}}
\newcommand{\Clo}{\texttt{Clo}}

\newcommand{\ctype}{\texttt{ctype}}
\newcommand{\csort}{\texttt{csort}}
\newcommand{\rec}{\texttt{rec}}
\newcommand{\fn}{\texttt{fn}}
\newcommand{\case}{\texttt{case}}
\newcommand{\of}{\texttt{of}}
\newcommand{\bbox}{\texttt{box}}

% Judgments
\newcommand{\block}{\texttt{block}}
\newcommand{\world}{\texttt{world}}
\newcommand{\schema}{\texttt{schema}}
\newcommand{\ctx}{\texttt{ctx}}
\newcommand{\mctx}{\texttt{mctx}}
\newcommand{\sctx}{\texttt{sctx}}
\newcommand{\sig}{\texttt{sig}}
\newcommand{\kind}{\texttt{kind}}

\newcommand{\cctx}{\texttt{cctx}}

\title{Proof Reuse}
\date{\today}
\author{Antoine Gaulin}


\begin{document}
    \maketitle

    % First paragraph is very bad, need an actual sujet amene
    It is common in the literature to reuse proofs of previously established results in order to derive new theorems.  A common pattern in papers
    is to start from a well understood language (often System F, LF, or the Calculus of Construction), add a new construct to it (e.g. subtyping,
    inductive types, etc.), and then show that the desirable properties of the original system are preserved.  Most proofs (at least for the basic
    properties) are by induction on the structure of the hypothesized derivation.  To conclude that the properties hold in the extension, it is then
    clearly sufficient to consider only the cases relevant to the new construct.  However, in mechanization, one would need to work through all the
    previously established cases once more.  This task is tedious and unnecessary.

    We investigate a few ways to simplify the development of mechanized proofs, the key idea being to reuse proofs when possible.
    The aim is to start from the type system of Beluga \cite{Pientka2008, PientkaDunfield2008} and look at a few extensions that allow 
    various forms of proof reuse.
    Through this process, we can also fix a major problem with how contexts are represented in Beluga, namely the inability to
    recover premisses needed for the formation of assumptions.

    The first direction is to extend the data-level type theory (i.e. the logical framework LF \cite{LF1987}) with refinements, 
    thus allowing a restricted form of subtyping to the language.
    This can then be lifted to context schemas, and then to the computation-level (i.e. the dependent contextual modal type theory \cite{Nanevski2008})
    in a mostly straightforward way.  The main idea behind refinements is to ``separate'' a type into \textit{sorts}.  While types express
    syntactic properties of terms, sorts express semantic properties.  They can therefore be used to enforce various properties on terms,
    while preserving type uniqueness.  In this case, we obtain a notion of subsorting rather than subtyping.  Ultimately, refinements allow
    a very limited form of proof reuse, and their usefulness is more in simplifying proofs.
    
    The second direction is to add constructor subtyping \cite{Poll1997, BarthesFrade1999}, which would be more accurately called \textit{supertyping}.
    This idea is simple : if a type $B$ has all the constuctors of another type $A$ and possibly more, then $B$ can be viewed as a supertype of $A$.
    Intuitively, this is because any object constructed with only the constructors defining $A$ could also be constructed by the constructors defining $B$.
    In this setting, we get a notion of co-inheritance \cite{Poll1997}.  This can be seen as dual to the inheritance mechanisms of object oriented programming,
    in the sense that a co-inherited function is lifted from a subtype to its supertype, and then extended with the cases to cover the extra constructors (if needed).
    
    % Might ditch ornaments for now, it's kind of complicated and mysterious
    The third direction is to add ornaments \cite{McBride2011}.  Here, we obtain systematic ways to enhance a type and/or its constructors with 
    additional dependencies, as well as a lifting mechanism to lift proofs on a type to its ornamented type.  Combining this with constructor subtyping,
    we should be able to present incremental development of languages and of their meta-theory, which would be closer to what is found in the literature.

    \textbf{Note}. In what follows, the comments classified as \textbf{Remark} are clarifications or observations, and those classified as \textbf{Note} 
    are either things that I didn't think of before I started typing this down, or places where I realized there is a mistake.


    \section{A refinement type system for Beluga}
    
    We start with refinements because it is the most invasive change to the language.  This is due to the fact that we now want to assign both sorts
    and types to terms, which is done in a single judgment.  This change is also present at the level of types, which are classified by both classes
    and kinds.  Thus, almost every inference rule must be adapted, although they keep the same flavor.  The core theory presented in this section is
    based on \cite{Pientka2008} and \cite{PientkaDunfield2008}, and the addition of refinements closely follows what is shown in \cite{LovasPfenning2010}.

    In the setting of refinements, every object should have a unique type (fully determined by its syntax), but possibly many different sorts.  Each 
    sort is restricted to a given type, and they express more specific properties that may of may not be satisfied by a given term of that type.  In 
    this sense, one may regard types as intrinsic properties, and sorts as extrinsic properties \cite{Pfenning2000}.  This allows us to specify properties
    without the need for additional types, which in turns simplifies the statement of theorems and their proofs.  Additionally, there is a natural 
    sub-sorting relation that is akin to logical implication, that is $S_1 \leq S_2 \sqsubset A$ if the property $S_1$ implies the property $S_2$ for
    any term of type $A$.  In particular, if we have proven a result on terms of sort $S_2$, then we can reuse the proof on terms of sort $S_1$.

    \subsection{Data-level}
    The data-level of Beluga includes the usual terms, types, and kinds, but also contexts and substitutions.  We add to the type level a notion of sorts,
    and to the kind level a similar notion of classes.  Contexts are classified using a notion of schema, which, in our extension, are built out of
    world declarations.  A world is a record of assumptions satisfying certain properties.  To ensure well-formedness of worlds, we use two syntactic
    categories : blocks and worlds.  A block is a dependent record (i.e. $\Sigma$-type), and a world is a function space whose image is a block.

    \subsubsection{Syntax}
    \begin{figure}[]
        \centering
        \begin{tabular}{rrl}
            Signatures              & $ \Sigma ::= $  & $ \cdot \mid \Sigma, D $ \\
%
            Declarations            & $ D ::= $       & $ \textbf{s} {::}L \sqsubset \textbf{a} {:} K \mid \textbf{c} {::} S \sqsubset A 
                                                          \mid \textbf{s}_1 \leq \textbf{s}_2 \sqsubset \textbf{a} \mid \textbf{w} {:} W 
                                                          \mid \boldsymbol{\xi} {:} \Xi $ \\
%
            Meta-contexts           & $ \Delta ::= $  & $ \cdot \mid \Delta, u{::}S[\Psi] \sqsubset A[\Psi] \mid \Delta, p{::}S[\Psi] \sqsubset A[\Psi]
                                                          \mid \Delta, s{:} \Psi_1[\Psi_2] \mid \Delta, \psi {:} \Xi$  \\
%
%            Schema contexts         & $ \Omega ::= $  & $ \cdot \mid \Omega, \psi  {:} \Xi $ \\
                                    &                 & \\
            Kinds                   & $ K ::= $       & $ \Type \mid \Pi x{:}A.K$ \\
            Classes                 & $ L ::= $       & $ \Sort \mid \Pi x{::}S. L \mid \top \mid L_1 \land L_2 $ \\
                                    &                 &  \\
            Atomic type families    & $ P ::= $       & $ \textbf{a} \mid P \ N $ \\
            Canonical type families & $ A ::= $       & $ P \mid \Pi x{:}A_1.A_2 $ \\
            %
            Atomic sort families    & $ Q ::= $       & $ \textbf{s} \mid Q \ N $ \\
            Canonical sort families & $ S ::= $       & $ Q \mid \Pi x{:}S_1 .S_2 \mid \top \mid S_1 \land S_2 $ \\
                                    &                 & \\
            Blocks                  & $ B ::= $       & $ S \sqsubset A \mid \Sigma x{::}S \sqsubset A. B$ \\
            Worlds                  & $ W ::= $       & $ B \mid \Pi x{::}S \sqsubset A. W $ \\
%            Worlds                  & $ W ::= $       & $ \langle \ell_i {::} S_i \sqsubset B_i \rangle_n \mid \Pi x{::}S \sqsubset A. W $ \\
            Schema                  & $ \Xi ::= $     & $ \varepsilon \mid \Xi + W $ \\
                                    &                 & \\
            Heads                   & $ H ::= $       & $ \textbf{c} \mid x \mid \proj \ k \ x \mid \Clo(x, s[\sigma]) \mid \#p[\sigma] \mid \proj \ k \ \#p $ \\
            Spines                  & $ \vec{M} ::= $ & $ \varepsilon \mid N ; \vec{M} $ \\
            Normal terms            & $ N ::= $       & $ R \mid \lambda x.N $\\
            Neutral terms           & $ R ::= $       & $ H \ \vec{M} \mid u[\sigma] $\\
                                    &                 & \\
            LF contexts             & $ \Psi ::= $    & $ \cdot \mid \Psi, x{::}S \sqsubset A \mid \Psi, x{:} (\textbf{w} \vec{M}) $ \\
            Substitutions           & $ \sigma ::= $  & $ \cdot \mid \wk_\psi \mid s[\sigma] \mid \sigma ; N $
        \end{tabular}
        \caption{Syntax of data-level}
        \label{fig:SyntaxData}
    \end{figure}

    The updated syntax of the language is given in Figure \ref{fig:SyntaxData}.  Most of the syntax that was already present in Beluga remains 
    unchanged (kinds, types, terms, and substitution, to be precise).  The main differences are in the contexts and signatures, where assumptions
    are endowed with a sort as well as a type.  Most importantly, LF contexts have an additional construct to associate variables to a given world,
    instead of just a type.  Finally, declarations are extended with subsorting and worlds.    

    In the syntax for sorts (and similarly for classes), $\top$ corresponds to all terms of the corresponding types, and $S_1 \land S_2$ is an intersection
    sort, so it classifies terms that can be classified by both $S_1$ and $S_2$.  

    In the syntax of worlds, records are denoted as $\langle \ell_i {::} S_i \sqsubset A_i \rangle_n$, where the subscript $n \geq 1$ indicates the 
    number of fields.  The $\Pi$'s in front of records can either be a parameter referred to by some of the fields, or assumptions needed to ensure
    the well-formedness of a given world.  Once we get to the sub-world judgment, we will see that using $\Pi$ is perhaps a bit misleading since the
    rules do not obey the familiar contravariance of $\Pi$-types.  So, we maybe we shouldn't think of them as functions, even though they seem like functions.

    Concerning the labels of worlds, I decided to take them out of the world's syntax itself, and rather consider them as names in declarations.  
    Ultimately, worlds should always be declared before they are used, so they would always be in the signature $\Sigma$.  This is just to avoid redundancy.

    \subsubsection{Judgments}
    As previously mentionned, most of the judgments take a slightly different form in the presence of refinements.  Let's first look at a 
    quick summary of the judgments :

    \begin{tabular}{ll}
        $ \vdash \Sigma \ \sig $                                       & Signature well-formedness \\
%        $ \vdash_\Sigma \Omega \ \sctx$                                 & Schema context well-formedness \\
        $ \vdash_\Sigma \Delta \ \mctx $                         & Meta-context well-formedness \\
        $  \Delta \vdash_\Sigma \Psi \ \ctx $                    & LF context well-formedness \\
        $  \Delta; \Psi \vdash_\Sigma L \sqsubset K $            & Class $L$ refines kind $K$ \\
        $  \Delta; \Psi \vdash_\Sigma Q \sqsubset P \Rar L $     & Atomic sort $Q$ synthesizes atomic type $P$ and class $L$ \\
        $  \Delta; \Psi \vdash_\Sigma S \sqsubset A \Lar \Sort $ & Sort $S$ refines type $A$ \\
        $  \Delta; \Psi \vdash_\Sigma N \Lar S \sqsubset A $     & Normal term $N$ checks against sort $S$ refining type $A$ \\
        $  \Delta; \Psi \vdash_\Sigma R \Rar S \sqsubset A $     & Neutral term $R$ synthesizes sort $S$ refining type $A$ \\
        $  \Delta; \Psi \vdash_\Sigma \sigma \Lar \Phi $         & Substitution $\sigma$ checks against LF context $\Phi$ \\
        $  \Delta; \Psi \vdash_\Sigma S_1 \leq S_2 \sqsubset A $ & $S_1$ is a sub-sort of $S_2$ as refinements of $A$ \\
        $  \Delta; \Psi \vdash_\Sigma W \ \world $               & $W$ is a well-formed world \\
        $  \Delta; \Psi \vdash_\Sigma \Xi \ \schema $            & $\Xi$ is a well-formed context schema \\
        $  \Delta; \Psi_1 \vdash_\Sigma \Psi_2 : \Xi $           & LF context $\Psi$ has schema $\Xi$ \\
        $  \Delta; \Psi \vdash_\Sigma W_1 \leq W_2 $             & $W_1$ is a sub-world of $W_2$\\
        $  \Delta; \Psi \vdash_\Sigma \Xi_1 \leq \Xi_2 $         & $\Xi_1$ is a sub-schema of $\Xi_2$
    \end{tabular}

    \textbf{Notes}. (1) There might be too many contexts in some of these judgments.  In particular, worlds and schemata should be closed, and the judgments
    for their well-formedness will only be used in signature formation, which requires all contexts to be empty.
    
    (2) It may be better to consider only LF contexts that have a schema rather than having a judgment for well-formed contexts and well-schemaed contexts.
    To achieve this, it would probably be necessary to enrich the notion of a context schema slightly.  In particular, we would need a schema that
    specify a particular sort/type for the right-most element(s) of the context since that is frequently used in mechanization.  The intuition for this
    comes from the fact that we usually don't consider terms that are not well-typed, or types that are not well-kinded, so it is odd to consider
    contexts that are not well-schemaed.  On the other hand, since contexts can have multiple schemata, we may want to consider the classifier 
    $\texttt{ctx}$ as analogous to types and schemata as analogous to sorts.  In this case, we could have a $\top$ schema to talk about arbitrary contexts,
    and merge the two judgments, just like we do for sorting/typing.

    Before presenting the rules defining each of these judgments, let us go over some conventions that will simplify notation.
    
    For all the judgments except signature validity, we omit the subscript $\Sigma$ since the signature is fixed throughout any derivation.
    In all judgments except for meta-context validity, we assume that $\Delta$ is well-formed, and similarly we assume that $\Psi$ is well-formed 
    in all the remaining judgments except LF context validity.  In practice, we would check that contexts are well-formed at the leaves of
    the proof trees.

    For the synthesis judgments (those with $\Rar$), the contexts, signatures and first object on the right of the turnstile
    are inputs, and the rest are outputs.  For instance, in $ \Delta; \Psi \vdash_\Sigma Q \sqsubset P \Rar L$, both $P$ and $L$ are outputs.
    For the remaining jugments, everything is considered an input.  In all judgments, we assume that every input is well-formed and in canonical form.
    To enforce this, we need to use hereditary substitutions.

    Finally, we assume that all names of constants and variables are unique.  Now, let's look at the inference rules.
    
    % Signature well-formedness
    $\boxed{\vdash \Sigma \ \sig}$
    
    \begin{align*}
        & \infer{\vdash \cdot \ \sig}{} &
        & \infer{\vdash \Sigma, \textbf{s}{::}L \sqsubset \textbf{a} {:}  K \ \sig}
          {
            \vdash \Sigma \ \sig
            &&
            \cdot ; \cdot ; \cdot \vdash_\Sigma L \sqsubset K
          }
    \end{align*}
    \begin{align*}
        & \infer{\vdash \Sigma, \textbf{c} {::} S \sqsubset A \ \sig}
          {
            \vdash \Sigma \ \sig
            &&
            \cdot ; \cdot ; \cdot \vdash_\Sigma S \sqsubset A \Lar \Sort
          } &
        & \infer{\vdash \Sigma, \textbf{s}_1 \leq \textbf{s}_2 \sqsubset \textbf{a}}
          {
            \vdash \Sigma \ \sig
            &&
            \textbf{s}_1 \sqsubset \textbf{a} {::} L \sqsubset K \in \Sigma
            &&
            \textbf{s}_2 \sqsubset \textbf{a} {::} L \sqsubset K \in \Sigma
          }
    \end{align*}
    \begin{align*}
        & \infer{\vdash \Sigma , \textbf{w} {:} W}
          {
            \vdash \Sigma \ \sig
            &&
            \cdot ; \cdot ; \cdot \vdash_\Sigma W \ \world
          } &
        & \infer{\vdash \Sigma , \boldsymbol{\xi} {:} \Xi}
          {
            \vdash \Sigma \ \sig
            &&
            \cdot ; \cdot ; \cdot \vdash_\Sigma \Xi \ \schema
          } &
    \end{align*}

    In the rules for signature formation, there is a notable change from what is shown in \cite{LovasPfenning2010}, namely that we don't have
    declarations of the form $\textbf{a} {:} K$ or $\textbf{c} : A$.  I think those are unnecessary since we can just replace them with declarations
    of the form $\top \sqsubset \textbf{a} {::} \top \sqsubset K$ and $\textbf{c} {::} \top \sqsubset A$, respectively.

    \textbf{Note}.  After giving it some thought, this wouldn't work since all our declarations must introduce names.  Nevertheless, we get a more
    uniform system by using $\top$ refinements in place of just kinds or types, so I would prefer to keep this approach and just add rules for
    these cases.


    % Meta-context well-formedness
    $\boxed{\vdash_\Sigma \Delta \ \mctx}$

    \begin{align*}
      & \infer{\vdash \cdot \ \mctx}{} &
      & \infer{\vdash \Delta, u{::} S[\Psi] \sqsubset A[\Psi]}
        {
          \vdash \Delta \ \mctx
          &&
          \Delta ; \Psi \vdash S \sqsubset A \Lar \Sort
        }
    \end{align*}
    \begin{align*}
      & \infer{\vdash \Delta, p{::} S[\Psi] \sqsubset A[\Psi]}
        {
          \vdash \Delta \ \mctx
          &&
          \Delta ; \Psi \vdash S \sqsubset A \Lar \Sort
        } &
      & \infer{\vdash \Delta, s{:} \Psi_1[\Psi_2]}
        {
          \vdash \Delta \ \mctx
          &&
          \Delta ; \Psi_2 \vdash \Psi_1 \ \ctx
        }
    \end{align*}
    \begin{align*}
      \infer{\vdash \Delta, \psi {:} \Xi \ \sctx}
            {
              \vdash \Delta \ \sctx
              &&
              \boldsymbol{\xi} {:} \Xi \in \Sigma
            }
    \end{align*}

    \textbf{Notes}. (1) I'm still unsure about the distinction between meta-variables ($u$) and parameter variables ($p$).  I think it's more about 
    the way they are used?  Specifically, $p$ should only be substituted with an ordinary variable.

    (2) In the rule for substitution variables, the premise $\Delta ; \Psi_2 \vdash \Psi_1 \ \ctx$ does not match the usual LF context well-formedness
    judgment, which is of the form $\Delta \vdash \Psi \ \ctx$ (i.e. without an LF context on the left side of the turnstile).  Maybe it should be
    a substitution judgment instead?  Otherwise, the context validity judgment could be generalized in a straightforward way. The only paper that 
    talks about substitution variables is \cite{Pientka2008}, but the context formation rules are not given there.

    % LF context well-formedness
    $\boxed{ \Delta \vdash_\Sigma \Psi \ \ctx}$

    \begin{align*}
      & \infer{\Delta \vdash \cdot \ \ctx}{} &
      & \infer{\Delta \vdash \Psi, x {::}S \sqsubset A \ \ctx}
        {
          \Delta \vdash \Psi \ \ctx
          &&
          \Delta ; \Psi \vdash S \sqsubset A \Lar \Sort
        }
    \end{align*}
    \begin{align*}
      \infer{\Delta \vdash \Psi, x{:} \textbf{w} \ \vec{M}}
            {
              \Delta \vdash \Psi \ \ctx
              &&
              \textbf{w} {:} \Pi (\overrightarrow{x{::}S \sqsubset A}).\langle \ell_i {::} S_i \sqsubset B_i \rangle_n \in \Sigma
              &&
              \Delta, \Psi \vdash \vec{M} \Lar \overrightarrow{S \sqsubset A}
            }
    \end{align*}

    \textbf{Remark}.  I've decided to use spines instead of substitutions for world parameters, mostly because users would want to refer to
    the terms during proofs, so that's what they would specify.

    % LF contexts relation
    $\boxed{\Delta \vdash_\Sigma \Psi_1 \leq \Psi_2}$

    \begin{align*}
      & \infer{\Delta \vdash \cdot \leq \cdot}{} &
      & \infer{\Delta \vdash (\Psi_1, x{::}S_1 \sqsubset A) \leq (\Psi_2, x{::}S_2)}
              {
                \Delta \vdash  \Psi_1 \leq \Psi_2
                &&
                \Delta; \Psi_2 \vdash S_1 \leq S_2 \sqsubset A
              }
    \end{align*}

    \textbf{Note}.  I'm not sure if we should have $\Delta; \Psi_1 \vdash S_1 \leq S_2 \sqsubset A$ as the premise (instead of the judgment with $\Psi_2$).
    In a subtyping rule, we would use the most precise type in the context, but here it is the least precise context that is used.

    % Kind refinements
    $\boxed{ \Delta; \Psi \vdash_\Sigma L \sqsubset K}$
    
    \begin{align*}
      & \infer{\Delta ; \Psi \vdash \Sort \sqsubset \Type}{} &
      & \infer{\Delta ; \Psi \vdash \Pi x{::}S.L \sqsubset \Pi x{:}A.K}
        {
          \Delta ; \Psi \vdash S \sqsubset A \Lar \Sort
          &&
          \Delta ; \Psi, x {:} S \sqsubset A \vdash L \sqsubset K
        }
    \end{align*}
    \begin{align*}
      & \infer{\Delta ; \Psi \vdash \top \sqsubset K}{} &
      & \infer{\Delta ; \Psi \vdash L_1 \land L_2 \sqsubset K}
        {
          \Delta ; \Psi  \vdash L_1 \sqsubset K
          &&
          \Delta ; \Psi  \vdash L_2 \sqsubset K
        }
    \end{align*}

    \textbf{Notes}. (1) For the rule with $\top$, we probably need a premise stating that $K$ is a well-formed kind, which implies that we need an extra
    judgment for kind validity (that would be exactly the same as what is already in Beluga).

    (2) Rules for \texttt{Rec} kinds are missing.

    % Class synthesis
    $\boxed{ \Delta; \Psi \vdash_\Sigma Q \sqsubset P \Rar L}$

    \begin{align*}
      & \infer{\Delta ; \Psi \vdash \textbf{s} \sqsubset \textbf{a} \Rar L}
        {
          \textbf{s} {::} L \sqsubset \textbf{a} {:} K \in \Sigma
        } &
      & \infer{\Delta; \Psi \vdash Q \ N \sqsubset P \ N \Rar [N/x]L}
        {
          \Delta ; \Psi \vdash Q \sqsubset P \Rar \Pi x{::}S. L
          &&
          \Delta ; \Psi \vdash N \Lar S \sqsubset A
        }
    \end{align*}
    \begin{align*}
      & \infer{\Delta ; \Psi \vdash Q \sqsubset P \Rar L_1}
        {
          \Delta ; \Psi \vdash Q \sqsubset P \Rar L_1 \land L_2
        } &
      & \infer{\Delta ; \Psi \vdash Q \sqsubset P \Rar L_2}
        {
          \Delta ; \Psi \vdash Q \sqsubset P \Rar L_1 \land L_2
        }
    \end{align*}

    % Class checking (only against Sort)
    $\boxed{\Delta ; \Psi \vdash_\Sigma S \sqsubset A \Lar \Sort}$

    \begin{align*}
      & \infer{\Delta; \Psi \vdash Q \sqsubset P \Lar \Sort}
        {
          \Delta; \Psi \vdash Q \sqsubset P \Rar \Sort
        } &
      & \infer{\Delta; \Psi \vdash \Pi x{::}S. S' \sqsubset \Pi x{:}A.A' \Lar \Sort}
        {
          \Delta; \Psi \vdash S \sqsubset A \Lar \Sort
          &&
          \Delta; \Psi, x{::}S \sqsubset A \vdash S' \sqsubset A'
        }
    \end{align*}
    \begin{align*}
      & \infer{\Delta; \Psi \vdash \top A \Lar \Sort}{} &
      & \infer{\Delta; \Psi \vdash S_1 \land S_2 \sqsubset A \Lar \Sort}
        {
          \Delta; \Psi \vdash S_1 \sqsubset A \Lar \Sort
          &&
          \Delta; \Psi \vdash S_2 \sqsubset A \Lar \Sort
        }
    \end{align*}

    \textbf{Note}.  Again, the rule for $\top$ should probably have a premise $\Delta; \Psi \vdash A \Lar \Type$, which requires adding
    a type well-formedness judgment.

    % Sort/type checking
    $\boxed{ \Delta; \Psi \vdash_\Sigma N \Lar S \sqsubset A}$

    \begin{align*}
      & \infer{\Delta; \Psi \vdash R \Lar S' \sqsubset A}
        {
          \Delta; \Psi \vdash R \Rar S \sqsubset A
          &&
          \Delta; \Psi \vdash S \leq S' \sqsubset A
        } &
      & \infer{\Delta; \Psi \vdash \lambda x.N \Lar \Pi x{::}S.S' \sqsubset \Pi x{:}A.A'}
        {
          \Delta; \Psi, x{::}S \sqsubset A \vdash N \Lar S' \sqsubset A'
        }
    \end{align*}
    \begin{align*}
      & \infer{\Delta; \Psi \vdash N \Lar S_1 \land S_2 \sqsubset A}
        {
          \Delta; \Psi \vdash N \Lar S_1 \sqsubset A
          &&
          \Delta; \Psi \vdash N \Lar S_2 \sqsubset A
        }
    \end{align*}

    % Sort/type synthesis
    $\boxed{ \Delta; \Psi \vdash_\Sigma R \Rar S \sqsubset A}$
    \begin{align*}
      & \infer{\Delta; \Psi \vdash \textbf{c} \Rar S \sqsubset A}
        {
          \textbf{c} {::} S \sqsubset A \in \Sigma
        } &
      & \infer{\Delta; \Psi \vdash x \Rar S \sqsubset A}
        {
          x {::} S \sqsubset A \in \Psi
        } 
    \end{align*}
    \begin{align*}
      \infer[(\text{for } 1 \leq k \leq n)]
            {\Delta; \Psi \vdash \proj \ k \ x \Rar [\ell_{k-1}; ..., \ell_1; \overleftarrow{M}]S_k \sqsubset [\ell_{k-1}; ..., \ell_1; \overleftarrow{M}] B_k}
            {
              x {:} \textbf{w} \ \vec{M} \in \Psi
              &&
              \textbf{w} {:} \Pi (\overrightarrow{y {::} S \sqsubset A}). \langle \ell_i {::} S_i \sqsubset B_i \rangle_n \in \Sigma
            }
    \end{align*}
    \begin{align*}
      \infer{\Delta; \Psi \vdash R \ N \Rar [N/x]S \sqsubset [N/x]A_2}
            {
              \Delta; \Psi \vdash R \Rar \Pi x{::}S_1 \sqsubset A_1. S_2 \sqsubset \Pi x{:}A_1. A_2
              &&
              \Delta; \Psi \vdash N \Lar S_1 \sqsubset A_1
            }
    \end{align*}
    \begin{align*}
      & \infer{\Delta; \Psi \vdash R \Rar S_1 \sqsubset A}
              {\Delta; \Psi \vdash R \Rar S_1 \land S_2 \sqsubset A} &
      & \infer{\Delta; \Psi \vdash R \Rar S_2 \sqsubset A}
              {\Delta; \Psi \vdash R \Rar S_1 \land S_2 \sqsubset A}
    \end{align*}
    
    \textbf{Remarks}. (1) In the rule for projections, $\overleftarrow{M}$ is just $\vec{M}$ backwards.  This is necessary since we construct spines
    from right to left, and substitutions from left to right.

    (2) Because of the last two rules regarding intersection sorts, the system is not deterministic.

    \textbf{Note}.  The rules for parameter variables, meta-variables, and closures are still missing.  

    % Substitutions
    $\boxed{ \Delta; \Psi_1 \vdash_\Sigma \sigma \Lar \Psi_2}$

    \begin{align*}
      & \infer{\Delta; \Psi_1 \vdash \cdot \Lar \cdot}{} &
      & \infer{\Delta; \Psi_1 \vdash s[\sigma] \Lar \Psi_2}
        {
          \Delta; \Psi_1 \vdash \sigma \Lar \Psi_2'
          &&
          s{::}\Psi_2[\Psi_2'] \in \Delta
        }
    \end{align*}
    \begin{align*}
      & \infer{\Delta; \psi, \Psi \vdash \wk_\psi \Lar \psi}{} &
      & \infer{\Delta; \Psi_1 \vdash (\sigma; N) \Lar (\Psi_2, x{::}S \sqsubset A)}
        {
          \Delta; \Psi_1 \vdash \sigma \Lar \Psi_2
          &&
          \Delta; \Psi_1 \vdash N \Lar S \sqsubset A
        }
    \end{align*}
    \begin{align*}
      \infer{\Delta; \Psi_1 \vdash (\sigma; B) \Lar (\Psi_2, x{:} \textbf{w} \ \vec{M})}
            {
              \Delta; \Psi \vdash \vec{M} \Lar \overrightarrow{S \sqsubset A}
              &&
              \Delta; \Psi, (\overrightarrow{x{::}S \sqsubset A}) \vdash B \ \block %\langle \ell_i {::} S_i \sqsubset B_i \rangle_n
            }
    \end{align*}

    \textbf{Notes}. (1) The rule for substitution of $x : \textbf{w} \ \vec{M}$ could be better.  In particular, the world's signature should appear
    in the premises to ensure well-formedness.

    (2) The rule for substitution variables could be enhanced with a context relation.  (Later, I'll ignore substitution variables for now)

    \textbf{Remark}.  The premise $\Delta; \Psi \vdash \overrightarrow{S \sqsubset A} \Lar \Sort$ checks that all the sorts are valid, given that 
    the previous ones are.  Formally, this auxilliary judgment is given by the following two rules :
    \begin{align*}
      & \infer{\Delta; \Psi \vdash S \sqsubset A ; \varepsilon \Lar \Sort}{ \Delta; \Psi \vdash S \sqsubset A \Lar \Sort} &
      & \infer{\Delta; \Psi \vdash S' \sqsubset A' ; \overrightarrow{S \sqsubset A} \Lar \Sort}
        {
          \Delta; \Psi \vdash \overrightarrow{S \sqsubset A} \Lar \Sort
          &&
          \Delta; \Psi, (\overrightarrow{x{::}S \sqsubset A}) \vdash S' \sqsubset A' \Lar \Sort
        }
    \end{align*}

    % Subsorting
    $\boxed{ \Delta; \Psi \vdash_\Sigma S_1 \leq S_2 \sqsubset A }$
    
    \begin{align*}
      & \infer{\Delta; \Psi \vdash S \leq S \sqsubset A}{\Delta; \Psi \vdash S \sqsubset A} &
      & \infer{\Delta; \Psi \vdash S_1 \leq S_3 \sqsubset A}
        {
          \Delta; \Psi \vdash S_1 \leq S_2 \sqsubset A
          &&
          \Delta; \Psi \vdash S_2 \leq S_3 \sqsubset A
        }
    \end{align*}
    \begin{align*}
      & \infer{\Delta; \Psi \vdash S \leq \top \sqsubset A}{\Delta; \Psi \vdash S \sqsubset A} &
      & \infer{\Delta; \Psi \vdash \Pi x{::}S_1. S_1' \leq \Pi x{::}S_2. S_2' \sqsubset \Pi x{:}A.A'}
        {
          \Delta; \Psi \vdash S_2 \leq S_1 \sqsubset A
          &&
          \Delta; \Psi \vdash S_1' \leq S_2' \sqsubset A'
        }
    \end{align*}
    \begin{align*}
      \infer{\Delta; \Psi \vdash S \leq S_1 \land S_2 \sqsubset A}
            { 
              \Delta; \Psi \vdash S \leq S_1 \sqsubset A
              &&
              \Delta; \Psi \vdash S \leq S_2 \sqsubset A
            }
    \end{align*}
    \begin{align*}
      & \infer{\Delta; \Psi \vdash S_1 \land S_2 \sqsubset A}
        { 
          \Delta; \Psi \vdash S_1 \leq S \sqsubset A
          &&
          \Delta; \Psi \vdash S_2 \sqsubset A \Lar \Sort
        } &
      & \infer{\Delta; \Psi \vdash S_1 \land S_2 \sqsubset A}
        { 
          \Delta; \Psi \vdash S_2 \leq S \sqsubset A
          &&
          \Delta; \Psi \vdash S_1 \sqsubset A \Lar \Sort
        }
    \end{align*}

    % Block well-formedness
    $\boxed{\Delta; \Psi \vdash_\Sigma B \ \block}$
    
    \begin{align*}
      & \infer{\Delta; \Psi \vdash (S \sqsubset A) \ \block}
              {
                \Delta; \Psi \vdash S \sqsubset A \Lar \Sort
              } &
      & \infer{\Delta; \Psi \vdash (\Sigma x{::}S \sqsubset A. B) \ \block}
              {
                \Delta; \Psi \vdash S \sqsubset A \Lar \Sort
                &&
                \Delta; \Psi, x{::} S \sqsubset A \vdash B \ \block
              }
    \end{align*}
    
    % World well-formedness    
    $\boxed{ \Delta; \Psi \vdash_\Sigma W \ \world}$

    \begin{align*}
      & \infer{\Delta; \Psi \vdash B \ \world}{\Delta; \Psi \vdash B \ \block} &
      & \infer{\Delta; \Psi \vdash (\Pi x{::}S \sqsubset A. W) \ \world}
              {
                \Delta; \Psi \vdash S \sqsubset A \Lar \Sort
                &&
                \Delta; \Psi, x{::} S \sqsubset A \vdash W \ \world
              }
    \end{align*}

    % Schema well-formedness
    $\boxed{ \Delta; \Psi \vdash_\Sigma \Xi \ \schema}$

    \begin{align*}
      & \infer{\Delta; \Psi \vdash \varepsilon \ \schema}{} &
      & \infer{\Delta; \Psi \vdash \Xi + \textbf{w} \ \schema}
        {
          \Delta; \Psi \vdash \Xi \ \schema
          &&
          \textbf{w} {:} W \in \Sigma
          &&
          \textbf{w} \notin \Xi
        }
    \end{align*}
    
    \textbf{Note}.  The judgments for world and schema validity and only used in signature formations, which requires the contexts to be empty.
    So, they may not be needed at all in this case.

    % Schemaing of LF contexts
    $\boxed{ \Delta \vdash_\Sigma \Psi : \Xi}$
    
    \begin{align*}
      & \infer{ \Delta \vdash \cdot {:} \varepsilon}{} &
      & \infer{ \Delta \vdash \psi {:} \Xi}{\psi {:} \Xi \in \Delta} &
      & \infer{ \Delta \vdash \Psi {:} \Xi_2}
        {
           \Delta \vdash \Psi {:} \Xi_1
          &&
           \Delta \vdash \Xi_1 \leq \Xi_2
        }
    \end{align*}
    \begin{align*}
      \infer{ \Delta \vdash (\Psi, x{:} \textbf{w} \ \vec{M}) : \Xi}
            {
               \Delta \vdash \Psi : \Xi
              &&
              \textbf{w} {:} \Pi \overrightarrow{x{::}S \sqsubset A}. \langle \ell_i {::} S_i \sqsubset B_i \rangle_n \in \Xi
              &&
              \Delta; \Psi \vdash \vec{M} \Lar \overrightarrow{S \sqsubset A}
            }
    \end{align*}

    \textbf{Note}. The judgment $ \Delta; \Psi \vdash \vec{M} \Lar \overrightarrow{S \sqsubset A}$ is just checking each of the terms in the 
    spine $\vec{M}$ against the corresponding type (which may depend on the previous terms).  Rules will be added soon.

    % Sub-blocks
    $\boxed{\Delta; \Psi \vdash_\Sigma B_1 \leq B_2}$
    \begin{align*}
      & \infer{\Delta; \Psi \vdash (S_1 \sqsubset A) \leq (S_2 \sqsubset A)}
              {
                \Delta; \Psi \vdash S_1 \leq S_2 \sqsubset A
              } &
      & \infer{\Delta; \Psi \vdash \Sigma x{::}S \sqsubset A. B_1 \leq B_2}
              {
                \Delta ; \Psi \vdash B_1 \leq B_2
                &&
                \Delta; \Psi \vdash S \sqsubset A \Lar \Sort
              }
    \end{align*}
    \begin{align*}
      \infer{\Delta; \Psi \vdash (\Sigma x{::} S_1 \sqsubset A).B_1 \leq (\Sigma x{::}S_2 \sqsubset A). B_2 }
            {
              \Delta; \Psi \vdash S_1 \leq S_2 \sqsubset A
              &&
              \Delta; \Psi, x{::}S_1 \sqsubset A \vdash B_1 \leq B_2
            }
    \end{align*}

    % Sub-worlds
    $\boxed{ \Delta; \Psi \vdash_\Sigma W_1 \leq W_2}$ \\
    \begin{align*}
      & \infer{\Delta; \Psi \vdash B_1 \leq B_2 \quad (\text{as worlds})}
              {
                \Delta; \Psi \vdash B_1 \leq B_2 \quad ( \text{as blocks})
              } &
      & \infer{\Delta; \Psi \vdash \Pi x{::}S \sqsubset A. W_1 \leq W_2}
              {
                \Delta ; \Psi \vdash W_1 \leq W_2
                &&
                \Delta; \Psi \vdash S \sqsubset A \Lar \Sort
              }
    \end{align*}
    \begin{align*}
      \infer{\Delta; \Psi \vdash (\Pi x{::} S_1 \sqsubset A).W_1 \leq (\Pi x{::}S_2 \sqsubset A). W_2 }
            {
              \Delta; \Psi \vdash S_1 \leq S_2 \sqsubset A
              &&
              \Delta; \Psi, x{::}S_1 \sqsubset A \vdash W_1 \leq W_2
            }
    \end{align*}

    \textbf{Remark}.  We stress that the last rule for sub-worlds does not satisfy the usual contravariance associated to subtyping of $\Pi$-types, which
    indicates that we may not want to consider $\Pi$-worlds as functions.  In addition, we also have this rule stating that having extra parameters yields
    sub-worlds, which is also not the case when subtyping function spaces.
    
    % Sub-schema
    $\boxed{ \Delta; \Psi \vdash_\Sigma \Xi_1 \leq \Xi_2}$
    \begin{align*}
      & \infer{\Delta; \Psi \vdash \varepsilon \leq \Xi}{\Delta; \Psi \vdash \Xi \ \schema} &
      & \infer{\Delta; \Psi \vdash \Xi_1 + W_1 \leq \Xi_2 + W_2}
        {
          \Delta; \Psi \vdash \Xi_1 \leq \Xi_2
          &&
          \Delta; \Psi \vdash W_1 \leq W_2
        } &
      & \infer{\Delta; \Psi \vdash \Xi_1 + \Xi_2 \leq \Xi_2 + \Xi_1}{\Delta; \Psi \vdash \Xi_1 + \Xi_2 \ \schema}
    \end{align*}

    \subsection{Computation-level}
    We can lift the data-level refinements to the computation-level to obtain a restricted notion of refinements where the user does not directly
    specify any sorts.  It could be interesting to have a full blown refinement type system, and it should not complicate matters too much.

    \subsubsection{Syntax}
    \begin{figure}[]
      \centering
      \begin{tabular}{rrl}
        Contexts                & $\Gamma ::=$ & $\cdot \mid \Gamma, y{::}\mu \sqsubset \kappa$ \\
                                &              & \\
        Kinds                   & $\kappa ::=$ & $\ctype \mid \Pi x{:}A[\Psi].\kappa$ \\
        Classes                 & $\zeta ::=$  & $\csort \mid \Pi x{::}S[\Psi]. \zeta \mid \top \mid \zeta_1 \land \zeta_2$ \\
                                &              & \\
        Types                   & $\tau ::=$   & $A[\Psi] \mid \tau_1 \rar \tau_2 \mid \Pi \psi{:}\Xi. \tau \mid \Pi^\square u{:}A[\Psi]. \tau$ \\
        Sorts                   & $\mu ::=$    & $S[\Psi] \mid \mu_1 \rar \mu_2 \mid \Pi \psi{:}\Xi.\mu \mid \Pi^\square u{::}S[\Psi].\mu 
                                                  \mid \top \mid \mu_1 \land \mu_2$ \\
                                &              & \\
        Checked expressions     & $e ::=$      & $i \mid \rec \ f.e \mid \fn \ y.e \mid \Lambda \psi. e \mid \lambda^\square u.e 
                                                  \mid \bbox(\Psi.M) \mid \case \ i \ \of \ bs$ \\
        Synthesized expressions & $i ::=$      & $y \mid i \ e \mid i \ \lceil \Psi \rceil \mid i \ \lceil \Psi. N \rceil \mid ( e{::} \mu \sqsubset \tau)$ \\
        Branch                  & $b ::=$      & $\Pi \Delta. \bbox(\Psi.M) {::} S[\Psi] \sqsubset A[\Psi] \mapsto e$ \\
        Branches                & $bs ::=$     & $\cdot \mid (b \mid bs)$
      \end{tabular}
      \caption{Syntax of computation level}
      \label{fig:SyntaxComp}
    \end{figure}

    The syntax for the computation level is given in Figure \ref{fig:SyntaxComp}.  Again, it is essentially the same as what is already in Beluga, except
    that we have sorts and classes.  However, in this case, we consider a restricted version that is fully induced by the refinements (and schemata) of
    the data level.

    \textbf{Notes}. (1) In practice, we allow user-defined computation-level type families, but they are not present in the current formulation.  To add
    them, we would need to extend the syntax for types and have addition declarations.  In this case, it wouldn't be much more work to add user-defined
    sorts.

    (2) For sorts, we may want to consider $\Pi^\square u{::}S[\Psi_1] \sqsubset A[\Psi_2]. \mu$ instead of having both LF contexts be identical, probably
    with the condition that $\Psi_1$ is contained in $\Psi_2$ (up to renaming).  In particular, we could have $\Psi_1 {:} \Xi_1$ and $\Psi_2 {:} \Xi_2$,
    where $\Xi_1 \leq \Xi_2$.

    (3) It may be better to have $\Pi x{:}A[\Psi].\kappa$ kinds, and similarly for classes.

    \subsubsection{Judgments}
    We have the follow computation level judgments :

    \begin{tabular}{ll}
      $ \Delta \vdash_\Sigma \Gamma \ \cctx$                                         & $\Gamma$ is a well-formed context \\
      $ \Delta; \Gamma \vdash_\Sigma \zeta \sqsubset \kappa$                       & Class $\zeta$ refines kind $\kappa$ \\
      $ \Delta; \Gamma \vdash_\Sigma \mu \sqsubset \tau \Lar \csort$               & Sort $\mu$ refines type $\tau$ \\
      $ \Delta; \Gamma \vdash_\Sigma e \Lar \mu \sqsubset \tau$                    & Expression $e$ checks agains sort $\mu$ refining type $\tau$ \\
      $ \Delta; \Gamma \vdash_\Sigma i \Rar \mu \sqsubset \tau$                    & Expression $i$ synthesizes saor $\mu$ refining type $\tau$ \\
      $ \Delta; \Gamma \vdash_\Sigma b \Lar_{\mu' \sqsubset \tau'} \mu \sqsubset \tau$ & Branch $b$ checks against $\mu$ refining $\tau$ 
                                                                                           when analyzing a $\mu'$ refining $\tau'$ \\
      $ \Delta; \Gamma \vdash_\Sigma \mu_1 \leq \mu_2 \sqsubset \tau$              & $\mu_1$ is a subsort of $\mu_2$ 
    \end{tabular}

    Again, we omit the subscript $\Sigma$ since it is fixed throughout any derivation, and we assume that all inputs are well-formed.  The system should
    be decidable if we follow the same input/output convention as in the data level (i.e. the synthesized sorts and types are outputs, and everything else
    is an input).  The judgments are defined via the following rules :

    \textbf{Notes.} (1) Just as in the data-level, it may be necessary to have judgments for kind and type well-formedness.

    (2) Since we are just lifting everything to the computation level, it may be redundant to have $\top$ and intersection computation-level sorts (and 
    classes) since they could probably always be inferred from $\top$ and intersection data-level sorts (and classes).

    (3) The rules for refinement should be enhanced with (LF) context relations

    % Context well-formedness
    $\boxed{ \Delta \vdash_\Sigma \Gamma \ \cctx}$
    
    \begin{align*}
      & \infer{ \Delta \vdash \cdot \ \cctx}{} &
      & \infer{ \Delta \vdash \Gamma, y{::}\mu \sqsubset \tau \ \cctx}
        {
           \Delta \vdash \Gamma \ \cctx
          &&
           \Delta; \Gamma \vdash \mu \sqsubset \tau \Lar \tau
        }
    \end{align*}

    % Class refining kinds
    $\boxed{ \Delta; \Gamma \vdash_\Sigma \zeta \sqsubset \kappa}$
    
    \begin{align*}
      & \infer{ \Delta; \Gamma \vdash \csort \sqsubset \ctype}{} &
      & \infer{ \Delta; \Gamma \vdash \top \sqsubset \kappa}{}
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash \Pi y{::}S[\Psi]. \zeta \sqsubset \Pi y{:}A[\Psi]. \kappa}
            {
               \Delta; \Psi \vdash S \sqsubset A
              &&
               \Delta; \Gamma, y{::}S[\Psi] \sqsubset A[\Psi] \vdash \zeta \sqsubset \kappa
            }
    \end{align*}    
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash \zeta_1 \land \zeta_2 \sqsubset \kappa}
            {
               \Delta; \Gamma \vdash \zeta_1 \sqsubset \kappa
              &&
               \Delta; \Gamma \vdash \zeta_2 \sqsubset \kappa
            }
    \end{align*}

    \textbf{Note}.  For the $\Pi$ rule, it indeed seems better to have the boxed LF contexts since we establish $S \sqsubset A$ at the data-level.

    % Sorts refining types
    $\boxed{ \Delta; \Gamma \vdash_\Sigma \mu \sqsubset \tau \Lar \csort}$

    \begin{align*}
      \infer{ \Delta; \Gamma \vdash S[\Psi] \sqsubset A[\Psi] \Lar \csort}
            { \Delta; \Psi \vdash S \sqsubset A \Lar \Sort}
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash \mu_1 \rar \mu_2 \sqsubset \tau_1 \rar \tau_2 \Lar \csort}
            {
               \Delta; \Gamma \vdash \mu_1 \sqsubset \tau_1 \Lar \csort
              &&
               \Delta; \Gamma, y{::}\mu_1 \sqsubset \tau_1 \vdash \mu_2 \sqsubset \tau_2 \Lar \csort
            }
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash \Pi^\square u{::} S[\Psi]. \mu \sqsubset \Pi^\square u{:}A[\Psi]. \tau \Lar \csort}
            {
               \Delta; \Psi \vdash S \sqsubset A \Lar \Sort
              &&
               \Delta, u{::}S[\Psi] \sqsubset A[\Psi]; \Gamma \vdash \mu \sqsubset \tau \Lar \csort
            }
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash\Pi \psi{:}\Xi_1 . \mu \sqsubset \Pi \psi{:}\Xi_2 . \tau \Lar \csort}
            {
               \Delta \vdash \Xi_1 \leq \Xi_2
              &&
              \Delta, \psi{:}\Xi_1; \Gamma \vdash \mu \sqsubset \tau
            }
    \end{align*}

    \textbf{Notes}. (1) Missing rules for $\top$ and intersection sorts.

    (2) It is not really necessary to mention $\csort$ everywhere in this judgment if we never check against other classes (although it's
    more likely that the other sorts are missing).

    % Expression sort/type-checking
    $\boxed{ \Delta; \Gamma \vdash_\Sigma e \Lar \mu \sqsubset \tau}$

    \begin{align*}
      & \infer{ \Delta; \Gamma \vdash i \Lar \mu' \sqsubset \tau}
        {
           \Delta; \Gamma \vdash i \Rar \mu \sqsubset \tau
          &&
           \Delta; \Gamma \vdash \mu \leq \mu' \sqsubset \tau
        } &
      & \infer{ \Delta; \Gamma \vdash \bbox(\Psi. M) \Lar S[\Psi] \sqsubset A[\Psi]}
        {
           \Delta; \Psi \vdash M \Lar S \sqsubset A
        }
    \end{align*}
    \begin{align*}
      & \infer{ \Delta; \Gamma \vdash \rec \ f.e \Lar \mu \sqsubset \tau}
        {
           \Delta; \Gamma, f{::}\mu \sqsubset \tau \vdash e \Lar \mu \sqsubset \tau
        } &
      & \infer{ \Delta; \Gamma \vdash \fn \ y.e \Lar \mu_1 \rar \mu_2 \sqsubset \tau_1 \rar \tau_2}
        {
           \Delta; \Gamma, y{::}\mu_1 \sqsubset \tau_1 \vdash e \Lar \mu_2 \sqsubset \tau_2
        }
    \end{align*}
    \begin{align*}
      & \infer{ \Delta; \Gamma \vdash \lambda^\square u.e \Lar \Pi^\square u{::}S[\Psi].\mu \sqsubset \Pi^\square u{:}A[\Psi]. \tau}
        {
           \Delta, u{::}S[\Psi] \sqsubset A[\Psi]; \Gamma \vdash e \Lar \mu \sqsubset \tau
        }
      & \infer{ \Delta; \Gamma \vdash \Lambda \psi. e \Lar \Pi \psi{:}\Xi.\mu \sqsubset \Pi \psi {:} \Xi. \tau}
        {
          \Delta, \psi{:}\Xi; \Gamma \vdash e \Lar \mu \sqsubset \tau
        }
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash \case \ i \ \of \ b_1 \mid ... \mid b_n \Lar \mu \sqsubset \tau}
            {
               \Delta; \Gamma \vdash i \Rar A[\Psi]
              &&
              \text{for all } k \  \Delta; \Gamma \vdash b_k \Lar_{S[\Psi] \sqsubset A[\Psi]} \mu \sqsubset \tau
            }
    \end{align*}

    % Expression sort/type synthesis
    $\boxed{ \Delta; \Gamma \vdash_\Sigma i \Rar \mu \sqsubset \tau}$
    
    \begin{align*}
      & \infer{ \Delta; \Gamma \vdash e \Lar \mu \sqsubset \tau}
        {
           \Delta; \Gamma \vdash (e {::} \mu \sqsubset \tau) \Rar \mu \sqsubset \tau
        } &
      & \infer{ \Delta; \Gamma \vdash y \Rar \mu \sqsubset \tau}{y{::}\mu \sqsubset \tau \in \Gamma}
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash i \ e \Rar \mu_2 \sqsubset \tau_2}
            {
               \Delta; \Gamma \vdash i \Rar \mu_1 \rar \mu_2 \sqsubset \tau_1 \rar \tau_2
              &&
               \Delta; \Gamma \vdash e \Lar \mu_1 \sqsubset \tau_1
            }
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash i \ \lceil \Psi \rceil \Rar \llbracket \Psi/\psi \rrbracket (\mu \sqsubset \tau)}
            {
               \Delta; \Gamma \vdash i \Rar \Pi \psi{:}\Xi_1. \mu \sqsubset \Pi \psi{:}\Xi_2. \tau
              &&
               \Delta; \Gamma \vdash \Psi : \Xi_1
            }
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash i \ \lceil \Psi. M \rceil \Rar \llbracket \Psi. M / u \rrbracket (\mu \sqsubset \tau)}
            {
               \Delta; \Gamma \vdash i \Rar \Pi^\square u{::}S[\Psi]. \mu \sqsubset \Pi^\square u{:}A[\Psi]. \tau
              &&
               \Delta; \Psi \vdash M \Lar S \sqsubset A
            }
    \end{align*}

    % Branch sorting/typing
    $\boxed{ \Delta; \Gamma \vdash_\Sigma b \Lar_{\mu' \sqsubset \tau'} \mu \sqsubset \tau}$

    \begin{align*}
      \infer{ \Delta; \Gamma \vdash \Pi \Delta_k . \bbox(\Psi. M_k) : S_k[\Psi_k]  \sqsubset A_k[\Psi_k] \mapsto e_k 
                                                \Lar_{S[\Psi] \sqsubset A[\Psi]} \mu \sqsubset \tau}
            {
               \Delta; \Gamma \vdash M_k \Lar S_k \sqsubset A_k
              &&
              \begin{array}{ll}
                 \Delta, \Delta_k & \vdash \Psi \doteq \Psi_k / (\theta_1, \Delta') \\
                 \Delta'          & \vdash \llbracket \theta_1 \rrbracket ( S \sqsubset A) \doteq 
                                                  \llbracket \theta_1 \rrbracket(S_k \sqsubset A_k)/(\theta_2, \Delta'') \\
                 \Delta'';\llbracket \theta_2 \rrbracket \llbracket \theta_1 \rrbracket \Gamma & \vdash
                                        \llbracket \theta_2 \rrbracket \llbracket \theta_1 \rrbracket e_k 
                                        \Lar \llbracket \theta_2 \rrbracket \llbracket \theta_1 \rrbracket (\mu \sqsubset \tau)
              \end{array}
            }
    \end{align*}

    % Subsorting
    $\boxed{ \Delta; \Gamma \vdash_\Sigma \mu_1 \leq \mu_2 \sqsubset \tau}$
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash S[\Psi] \sqsubset A[\Psi]}
            {
               \Delta; \Psi \vdash S \sqsubset A
            }
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash\mu_1 \rar \mu_1' \leq \mu_2 \rar \mu_2' \sqsubset \tau \rar \tau'}
            {
               \Delta; \Gamma \vdash \mu_2 \leq \mu_1 \sqsubset \tau
              &&
               \Delta; \Gamma, y{::} \mu_2 \sqsubset \tau \vdash \mu_1' \leq \mu_2' \sqsubset \tau'
            }
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash\Pi^\square u{::}S_1[\Psi]. \mu_1 \leq \Pi^\square u{::}S_2[\Psi]. \mu_2 \sqsubset \Pi^\square u{:} A[\Psi]. \tau}
            {
               \Delta; \Psi \vdash S_2 \leq S_1 \sqsubset A
              &&
               \Delta, u{::} S_2[\Psi] \sqsubset A[\Psi]; \Gamma \vdash \mu_1 \leq \mu_2 \sqsubset \tau
            }
    \end{align*}
    \begin{align*}
      \infer{ \Delta; \Gamma \vdash \Pi \psi{:}\Xi_1. \mu_1 \leq \psi{:}\Xi_2. \mu_2 \sqsubset \Pi \psi{:}\Xi. \tau}
            {
               \Delta \vdash \Xi_1 \leq \Xi_2
              &&
               \Delta \vdash \Xi_2 \leq \Xi
              &&
              \Delta,\psi{:}\Xi_1; \Gamma \vdash \mu_1 \leq \mu_2 \sqsubset \tau
            }
    \end{align*}

    \section{Constructor subtyping}
    TBD

    \section{Ornaments}
    TBD

    \bibliographystyle{acm}
    \bibliography{bibliography}    
\end{document}
