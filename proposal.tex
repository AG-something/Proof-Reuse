\documentclass[letterpaper, 11pt]{article}
\usepackage{amsmath, amssymb, amsfonts}%math
\usepackage{mathtools}
\usepackage[left=2cm,right=2cm,top=2.75cm,bottom=2.75cm]{geometry}%margins
\usepackage[utf8x]{inputenc}%ASCII characters
\usepackage[T1]{fontenc}
\usepackage{lmodern}%for accentuated characters and accents
\usepackage{graphicx}%inserting pdf-jpg pictures
\usepackage[natural, dvipsnames, pdftex]{xcolor}
\usepackage{tikz} %Drawing pretty pictures
\usepackage{verbatim} %adding code
\usepackage[pdftex,  colorlinks=true]{hyperref}%Hyperlinks, with \href
\hypersetup{urlcolor=RoyalBlue,  linkcolor=RedOrange,  citecolor=black}

\usepackage{proof} %for proof trees
\usepackage{mathdots}

\DeclareMathAlphabet{\mathpzc}{OT1}{pzc}{m}{n} %mathpzc alphabet
\usepackage[mathscr]{eucal} %mathscr alphabet

%Redefine theorem environments
\usepackage[amsmath,  thref,  thmmarks,  hyperref]{ntheorem}


%Redefining theorem style
\theoremheaderfont{\bf}
\theorembodyfont{\normalfont}

\newtheorem*{theorem}{Theorem}[section]
\newtheorem*{lemma}[subsection]{Lemma}
\newtheorem{cor}[subsection]{Corollary}
\newtheorem{prop}[subsection]{Proposition}
\newtheorem*{claim}{Claim}
\newtheorem*{sol}{Solution}
\newtheorem{defn}[theorem]{Definition}
\newtheorem{ex}{Example}[section]
\newtheorem*{remark}{Remark}[section]
\newtheorem*{obs}{Observation}[section]
\newtheorem*{note}{Note}[section]
\renewcommand{\Box}{\rule{1.5ex}{1.5ex}}  % end of proof


\newenvironment*{proof}{\par\noindent{\normalfont{\bf{Proof. \\ \hphantom{mm}
}}}}{\hfill \small$\blacksquare$\\[-4pt]}


\usepackage{verbments}%fancy verbatim
\usepackage[shortlabels]{enumitem}


% Symbols
\newcommand{\Rar}{\Rightarrow}
\newcommand{\Lar}{\Leftarrow}


%% keywords
% Syntax
\newcommand{\Type}{\texttt{Type}}
\newcommand{\Rec}{\texttt{Rec}}
\newcommand{\Sort}{\texttt{Sort}}
\newcommand{\wk}{\texttt{wk}}
\newcommand{\proj}{\texttt{proj}}
\newcommand{\Clo}{\texttt{Clo}}

% Judgments
\newcommand{\world}{\texttt{world}}
\newcommand{\schema}{\texttt{schema}}
\newcommand{\ctx}{\texttt{ctx}}
\newcommand{\mctx}{\texttt{mctx}}
\newcommand{\sctx}{\texttt{sctx}}
\newcommand{\sig}{\texttt{sig}}
\newcommand{\kind}{\texttt{kind}}

\title{Proof Reuse}
\date{\today}
\author{Antoine Gaulin}


\begin{document}
    \maketitle
    
    It is common in the literature to reuse proofs of previously established results in order to derive new theorems.  A common pattern in papers
    is to start from a well understood language (often System F, LF, or the Calculus of Construction), add a new construct to it (e.g. subtyping,
    inductive types, etc.), and then show that the desirable properties of the original system are preserved.  Most proofs (at least for the basic
    properties) are by induction on the structure of the hypothesized derivation.  To conclude that the properties hold in the extension, it is then
    clearly sufficient to consider only the cases relevant to the new construct.  However, in mechanization, one would need to work through all the
    previously established cases once more.  This task is tedious and unnecessary.

    We investigate a few ways to simplify the development of mechanized proofs, the key idea being to reuse proofs when possible.
    The aim is to start from the type system of Beluga \cite{Pientka2008, PientkaDunfield2008} and look at a few extensions that allow 
    various forms of proof reuse.
    Through this process, we can also fix a major problem with how contexts are represented in Beluga, namely the inability to
    recover premisses needed for the formation of assumptions.

    The first direction is to extend the data-level type theory (i.e. the logical framework LF \cite{LF1987}) with refinements, 
    thus allowing a restricted form of subtyping to the language.
    This can then be lifted to context schemas, and then to the computation-level (i.e. the dependent contextual modal type theory \cite{Nanevski2008})
    in a mostly straightforward way.  The main idea behind refinements is to ``separate'' a type into \textit{sorts}.  While types express
    syntactic properties of terms, sorts express semantic properties.  They can therefore be used to enforce various properties on terms,
    while preserving type uniqueness.  In this case, we obtain a notion of subsorting rather than subtyping.  Ultimately, refinements allow
    a very limited form of proof reuse, and their usefulness is more in simplifying proofs.
    
    The second direction is to add constructor subtyping \cite{Poll1997, BarthesFrade1999}, which would be more accurately called \textit{supertyping}.
    This idea is simple : if a type $B$ has all the constuctors of another type $A$ and possibly more, then $B$ can be viewed as a supertype of $A$.
    In this setting, we get a notion of co-inheritance, similar to the inheritance mechanism found in object oriented programming.

    The third direction is to add ornaments \cite{McBride2011}.  Here, we obtain systematic ways to enhance a type and/or its constructors with 
    additional dependencies, as well as a lifting mechanism to lift proofs on a type to its ornamented type.  Combining this with constructor subtyping,
    we should be able to present incremental development of languages and of their meta-theory, which would be closer to what is found in the literature.

    \textbf{Note}. In what follows, the comments classified as \textbf{Remark} are clarifications or observations, and those classified as \textbf{Note} 
    are either things that I didn't think of before I started typing this down, or places where I realized there is a mistake.


    \section{A refinement type system for Beluga}
    
    We start with refinements because it is the most invasive change to the language.  This is due to the fact that we now want to assign both sorts
    and types to terms, which is done in a single judgment.  This change is also present at the level of types, which are classified by both classes
    and kinds.  Thus, almost every inference rule must be adapted, although they keep the same flavor.  The core theory presented in this section is
    based on \cite{Pientka2008} and \cite{PientkaDunfield2008}, and the addition of refinements closely follows what is shown in \cite{LovasPfenning2010}.

    \subsection{Data-level}
    The data-level of Beluga includes the usual terms, types, and kinds, but also contexts and substitutions.  We add to the type level a notion of sorts,
    and to the kind level a similar notion of classes.  Contexts are classified using a notion of schema, which, in our extension, are built out of
    world declarations.  A world is a record of assumptions satisfying certain properties.  In order to ensure well-formedness 
    of worlds and schemata, we introduce an additional base kind \texttt{Rec} for records.  

    \textbf{Note}. It may be necessary to add a corresponding sort \texttt{RecSort} to characterize refinement records.  This would also allow a
    subsorting mechanism on records, which could simplify the sub-worlds and sub-schema relationships.  

    \subsubsection{Syntax}
    \begin{figure}[tbp]
        \centering
        \begin{tabular}{rrl}
            Signatures              & $ \Sigma ::= $  & $ \cdot \mid \Sigma, D $ \\
%
            Declarations            & $ D ::= $       & $ \textbf{s} \sqsubset \textbf{a} {:} L \sqsubset K \mid \textbf{c} {::} S \sqsubset A 
                                                          \mid \textbf{s}_1 \leq \textbf{s}_2 \sqsubset \textbf{a} \mid \textbf{w} {:} W 
                                                          \mid \boldsymbol{\xi} {:} \Xi $ \\
%
            Meta-contexts           & $ \Delta ::= $  & $ \cdot \mid \Delta, u{::}S[\Psi] \sqsubset A[\Psi] 
                                                          \mid \Delta, p{::}S[\Psi] \sqsubset A[\Psi] \mid \Delta, s{:} \Psi_1[\Psi_2] $  \\
%
            Schema contexts         & $ \Omega ::= $  & $ \cdot \mid \Omega, \psi  {:} \Xi $ \\
                                    &                 & \\
            Kinds                   & $ K ::= $       & $ \Type \mid \Rec \mid \Pi x{:}A.K$ \\
            Classes                 & $ L ::= $       & $ \Sort \mid \Pi x{::}S \sqsubset A. L \mid \top \mid L_1 \land L_2 $ \\
                                    &                 &  \\
            Atomic type families    & $ P ::= $       & $ \textbf{a} \mid P \ \vec{M} $ \\
            Canonical type families & $ A ::= $       & $ P \mid \Pi x{:}A_1.A_2 $ \\
            %
            Atomic sort families    & $ Q ::= $       & $ \textbf{s} \mid Q \ \vec{M} $ \\
            Canonical sort families & $ S ::= $       & $ Q \mid \Pi x{:}S_1 \sqsubset A_1.S_2 \mid \top \mid S_1 \land S_2 $ \\
                                    &                 & \\
            Worlds                  & $ W ::= $       & $ \langle \ell_i {::} S_i \sqsubset B_i \rangle_n \mid \Pi x{::}S \sqsubset A. W $ \\
            Schema                  & $ \Xi ::= $     & $ \varepsilon \mid \Xi + W $ \\
                                    &                 & \\
            Heads                   & $ H ::= $       & $ \textbf{c} \mid x \mid \proj \ k \ x \mid \Clo(x, s[\sigma]) \mid \#p[\sigma] \mid \proj \ k \ \#p $ \\
            Spines                  & $ \vec{M} ::= $ & $ \varepsilon \mid N ; \vec{M} $ \\
            Normal terms            & $ N ::= $       & $ R \mid \lambda x.N $\\
            Neutral terms           & $ R ::= $       & $ H \ \vec{M} \mid u[\sigma] $\\
                                    &                 & \\
            LF contexts             & $ \Psi ::= $    & $ \cdot \mid \Psi, x{::}S \sqsubset A \mid \Psi, x{:} (\textbf{w} \vec{M}) $ \\
            Substitutions           & $ \sigma ::= $  & $ \cdot \mid \wk_\psi \mid s[\sigma] \mid \sigma ; N $
        \end{tabular}
        \caption{Syntax of data-level}
        \label{fig:SyntaxData}
    \end{figure}

    The updated syntax of the language is given in Figure \ref{fig:SyntaxData}.  Most of the syntax that was already present in Beluga remains 
    unchanged (kinds, types, terms, and substitution, to be precise).  The main differences are in the contexts and signatures, where assumptions
    are endowed with a sort as well as a type.  Most importantly, LF contexts have an additional construct to associate variables to a given world,
    instead of just a type.  Finally, declarations are extended with subsorting and worlds.    

    In the syntax of worlds, records are denoted as $\langle \ell_i {::} S_i \sqsubset A_i \rangle_n$, where the subscript $n \geq 1$ indicates the 
    number of fields.  The $\Pi$'s in front of records can either be a parameter referred to by some of the fields, or assumptions needed to ensure
    the well-formedness of a given world.  Once we get to the sub-world judgment, we will see that using $\Pi$ is perhaps a bit misleading since the
    rules do not obey the familiar contravariance of $\Pi$-types.  So, we maybe we shouldn't think of them as functions, even though they seem like functions.

    Concerning the labels of worlds, I decided to take them out of the world's syntax itself, and rather consider them as names in declarations.  
    Ultimately, worlds should always be declared before they are used, so they would always be in the signature $\Sigma$.  This is just to avoid redundancy.

    \subsubsection{Judgments}
    As previously mentionned, most of the judgments take a slightly different form in the presence of refinements.  Let's first look at a 
    quick summary of the judgments :

    \begin{tabular}{ll}
        $ \vdash \Sigma \ \sig $                                       & Signature well-formedness \\
        $ \vdash_\Sigma \Omega \ \sctx$                                 & Schema context well-formedness \\
        $ \Omega \vdash_\Sigma \Delta \ \mctx $                         & Meta-context well-formedness \\
        $ \Omega; \Delta \vdash_\Sigma \Psi \ \ctx $                    & LF context well-formedness \\
        $ \Omega; \Delta; \Psi \vdash_\Sigma L \sqsubset K $            & Class $L$ refines kind $K$ \\
        $ \Omega; \Delta; \Psi \vdash_\Sigma Q \sqsubset P \Rar L $     & Atomic sort $Q$ synthesizes atomic type $P$ and class $L$ \\
        $ \Omega; \Delta; \Psi \vdash_\Sigma S \sqsubset A \Lar \Sort $ & Sort $S$ refines type $A$ \\
        $ \Omega; \Delta; \Psi \vdash_\Sigma N \Lar S \sqsubset A $     & Normal term $N$ checks against sort $S$ refining type $A$ \\
        $ \Omega; \Delta; \Psi \vdash_\Sigma R \Rar S \sqsubset A $     & Neutral term $R$ synthesizes sort $S$ refining type $A$ \\
        $ \Omega; \Delta; \Psi \vdash_\Sigma \sigma \Lar \Phi $         & Substitution $\sigma$ checks against LF context $\Phi$ \\
        $ \Omega; \Delta; \Psi \vdash_\Sigma S_1 \leq S_2 \sqsubset A $ & $S_1$ is a sub-sort of $S_2$ as refinements of $A$ \\
        $ \Omega; \Delta; \Psi \vdash_\Sigma W \ \world $               & $W$ is a well-formed world \\
        $ \Omega; \Delta; \Psi \vdash_\Sigma \Xi \ \schema $            & $\Xi$ is a well-formed context schema \\
        $ \Omega; \Delta; \Psi \vdash_\Sigma \Psi : \Xi $               & LF context $\Psi$ has schema $\Xi$ \\
        $ \Omega; \Delta; \Psi \vdash_\Sigma W_1 \leq W_2 $             & $W_1$ is a sub-world of $W_2$\\
        $ \Omega; \Delta; \Psi \vdash_\Sigma \Xi_1 \leq \Xi_2 $         & $\Xi_1$ is a sub-schema of $\Xi_2$
    \end{tabular}

    Before presenting the rules defining each of these judgments, let us go over some conventions that will simplify notation.
    
    For all the judgments except signature validity, we omit the subscript $\Sigma$ since the signature is fixed throughout any derivation.
    Similarly, the schema context $\Omega$ is fixed except for the schema context well-formedness judgment, so we omit it as well.  In all judgments
    except for meta-context validity, we assume that $\Delta$ is well-formed, and similarly we assume that $\Psi$ is well-formed in all judgments
    except LF context validity.  

    For the synthesis judgments (those with $\Rar$), the contexts, signatures and first object on the right of the turnstile
    are inputs, and the rest are outputs.  For instance, in $\Omega; \Delta; \Psi \vdash_\Sigma Q \sqsubset P \Rar L$, both $P$ and $L$ are outputs.
    For the remaining jugments, everything is considered an input.  In all judgments, we assume that every input is well-formed and in canonical form.
    To enforce this, we need to use hereditary substitutions.

    Finally, we assume that all names of constants and variables are unique.  Now, let's look at the inference rules.
    
    % Signature well-formedness
    $\boxed{\vdash \Sigma \ \sig}$
    
    \begin{align*}
        & \infer{\vdash \cdot \ \sig}{} &
        & \infer{\vdash \Sigma, \textbf{s} \sqsubset \textbf{a} {::} L \sqsubset K \ \sig}
          {
            \vdash \Sigma \ \sig
            &&
            \cdot ; \cdot ; \cdot \vdash_\Sigma L \sqsubset K
          }
    \end{align*}
    \begin{align*}
        & \infer{\vdash \Sigma, \textbf{c} {::} S \sqsubset A \ \sig}
          {
            \vdash \Sigma \ \sig
            &&
            \cdot ; \cdot ; \cdot \vdash_\Sigma S \sqsubset A \Lar \Sort
          } &
        & \infer{\vdash \Sigma, \textbf{s}_1 \leq \textbf{s}_2 \sqsubset \textbf{a}}
          {
            \vdash \Sigma \ \sig
            &&
            \textbf{s}_1 \sqsubset \textbf{a} {::} L \sqsubset K \in \Sigma
            &&
            \textbf{s}_2 \sqsubset \textbf{a} {::} L \sqsubset K \in \Sigma
          }
    \end{align*}
    \begin{align*}
        & \infer{\vdash \Sigma , \textbf{w} {:} W}
          {
            \vdash \Sigma \ \sig
            &&
            \cdot ; \cdot ; \cdot \vdash_\Sigma W \ \world
          } &
        & \infer{\vdash \Sigma , \boldsymbol{\xi} {:} \Xi}
          {
            \vdash \Sigma \ \sig
            &&
            \cdot ; \cdot ; \cdot \vdash_\Sigma \Xi \ \schema
          } &
    \end{align*}

    In the rules for signature formation, there is a notable change from what is shown in \cite{LovasPfenning2010}, namely that we don't have
    declarations of the form $\textbf{a} {:} K$ or $\textbf{c} : A$.  I think those are unnecessary since we can just replace them with declarations
    of the form $\top \sqsubset \textbf{a} {::} \top \sqsubset K$ and $\textbf{c} {::} \top \sqsubset A$, respectively.

    \textbf{Note}.  After giving it some thought, this wouldn't work since all our declarations must introduce names.  Nevertheless, we get a more
    uniform system by using $\top$ refinements in place of just kinds or types, so I would prefer to keep this approach and just add rules for
    these cases.

    % Schema context well-formedness
    $\boxed{\vdash_\Sigma \Omega \ \sctx}$

    \begin{align*}
      & \infer{\vdash \cdot \ \sctx}{} &
      & \infer{\vdash \Omega, \psi {:} \Xi \ \sctx}
        {
          \vdash \Omega \ \sctx
          &&
          \boldsymbol{\xi} {:} \Xi \in \Sigma
        }
    \end{align*}

    \textbf{Remark}.  Maybe the names $\boldsymbol{\xi}$ are unnecessary in the signature.

    % Meta-context well-formedness
    $\boxed{\Omega \vdash_\Sigma \Delta \ \mctx}$

    \begin{align*}
      & \infer{\vdash \cdot \ \mctx}{} &
      & \infer{\vdash \Delta, u{::} S[\Psi] \sqsubset A[\Psi]}
        {
          \vdash \Delta \ \mctx
          &&
          \Delta ; \Psi \vdash S \sqsubset A \Lar \Sort
        }
    \end{align*}
    \begin{align*}
      & \infer{\vdash \Delta, p{::} S[\Psi] \sqsubset A[\Psi]}
        {
          \vdash \Delta \ \mctx
          &&
          \Delta ; \Psi \vdash S \sqsubset A \Lar \Sort
        } &
      & \infer{\vdash \Delta, s{:} \Psi_1[\Psi_2]}
        {
          \vdash \Delta \ \mctx
          &&
          \Delta ; \Psi_2 \vdash \Psi_1 \ \ctx
        }
    \end{align*}

    \textbf{Notes}. (1) I'm still unsure about the distinction between meta-variables ($u$) and parameter variables ($p$).  I think it's more about 
    the way they are used?  Specifically, $p$ should only be substituted with an ordinary variable.

    (2) In the rule for substitution variables, the premise $\Delta ; \Psi_2 \vdash \Psi_1 \ \ctx$ does not match the usual LF context well-formedness
    judgment, which is of the form $\Delta \vdash \Psi \ \ctx$ (i.e. without an LF context on the left side of the turnstile).  Maybe it should be
    a substitution judgment instead?  Otherwise, the context validity judgment could be generalized in a straightforward way. The only paper that 
    talks about substitution variables is \cite{Pientka2008}, but the context formation rules are not given there.

    % LF context well-formedness
    $\boxed{\Omega ; \Delta \vdash_\Sigma \Psi \ \ctx}$

    \begin{align*}
      & \infer{\Delta \vdash \cdot \ \ctx}{} &
      & \infer{\Delta \vdash \Psi, x {::}S \sqsubset A \ \ctx}
        {
          \Delta \vdash \Psi \ \ctx
          &&
          \Delta ; \Psi \vdash S \sqsubset A \Lar \Sort
        }
    \end{align*}
    \begin{align*}
      \infer{\Delta \vdash \Psi, x{:} \textbf{w} \ \vec{M}}
            {
              \Delta \vdash \Psi \ \ctx
              &&
              \textbf{w} {:} \Pi (\overrightarrow{x{::}S \sqsubset A}).\langle \ell_i {::} S_i \sqsubset B_i \rangle_n \in \Sigma
              &&
              \Delta, \Psi \vdash \vec{M} \Lar \overrightarrow{S \sqsubset A}
            }
    \end{align*}

    \textbf{Remark}.  I've decided to use spines instead of substitutions for world parameters, mostly because users would want to refer to
    the terms during proofs, so that's what they would specify.

    % Kind refinements
    $\boxed{\Omega; \Delta; \Psi \vdash_\Sigma L \sqsubset K}$
    
    \begin{align*}
      & \infer{\Delta ; \Psi \vdash \Sort \sqsubset \Type}{} &
      & \infer{\Delta ; \Psi \vdash \Pi x{::}S \sqsubset A.L \sqsubset \Pi x{:}A.K}
        {
          \Delta ; \Psi \vdash S \sqsubset A \Lar \Sort
          \Delta ; \Psi, x {:} S \sqsubset A \vdash L \sqsubset K
        }
    \end{align*}
    \begin{align*}
      & \infer{\Delta ; \Psi \vdash \top \sqsubset K}{} &
      & \infer{\Delta ; \Psi \vdash L_1 \land L_2 \sqsubset K}
        {
          \Delta ; \Psi  \vdash L_1 \sqsubset K
          &&
          \Delta ; \Psi  \vdash L_2 \sqsubset K
        }
    \end{align*}

    \textbf{Notes}. (1) For the rule with $\top$, we probably need a premise stating that $K$ is a well-formed kind, which implies that we need an extra
    judgment for kind validity (that would be exactly the same as what is already in Beluga).

    (2) Rules for \texttt{Rec} kinds are missing.

    % Class synthesis
    $\boxed{\Omega; \Delta; \Psi \vdash_\Sigma Q \sqsubset P \Rar L}$

    \begin{align*}
      & \infer{\Delta ; \Psi \vdash \textbf{s} \sqsubset \textbf{a} \Rar L}
        {
          \textbf{s} \sqsubset \textbf{a} {::} L \sqsubset K \in \Sigma
        } &
      & \infer{\Delta; \Psi \vdash Q \ N \sqsubset P \ N \Rar [N/x]L}
        {
          \Delta ; \Psi \vdash Q \sqsubset P \Rar \Pi x{::}S \sqsubset A. L
          &&
          \Delta ; \Psi \vdash N \Lar S \sqsubset A
        }
    \end{align*}
    \begin{align*}
      & \infer{\Delta ; \Psi \vdash Q \sqsubset P \Rar L_1}
        {
          \Delta ; \Psi \vdash Q \sqsubset P \Rar L_1 \land L_2
        } &
      & \infer{\Delta ; \Psi \vdash Q \sqsubset P \Rar L_2}
        {
          \Delta ; \Psi \vdash Q \sqsubset P \Rar L_1 \land L_2
        }
    \end{align*}

    % Class checking (only against Sort)
    $\boxed{\Omega ; \Delta ; \Psi \vdash_\Sigma S \sqsubset A \Lar \Sort}$

    \begin{align*}
      & \infer{\Delta; \Psi \vdash Q \sqsubset P \Lar \Sort}
        {
          \Delta; \Psi \vdash Q \sqsubset P \Rar \Sort
        } &
      & \infer{\Delta; \Psi \vdash \Pi x{::}S \sqsubset A. S' \sqsubset \Pi x{:}A.A' \Lar \Sort}
        {
          \Delta; \Psi \vdash S \sqsubset A \Lar \Sort
          &&
          \Delta; \Psi, x{::}S \sqsubset A \vdash S' \sqsubset A'
        }
    \end{align*}
    \begin{align*}
      & \infer{\Delta; \Psi \vdash \top A \Lar \Sort}{} &
      & \infer{\Delta; \Psi \vdash S_1 \land S_2 \sqsubset A \Lar \Sort}
        {
          \Delta; \Psi \vdash S_1 \sqsubset A \Lar \Sort
          &&
          \Delta; \Psi \vdash S_2 \sqsubset A \Lar \Sort
        }
    \end{align*}

    \textbf{Note}.  Again, the rule for $\top$ should probably have a premise $\Delta; \Psi \vdash A \Lar \Type$, which requires adding
    a type well-formedness judgment.

    % Sort/type checking
    $\boxed{\Omega; \Delta; \Psi \vdash_\Sigma N \Lar S \sqsubset A}$

    \begin{align*}
      & \infer{\Delta; \Psi \vdash R \Lar S' \sqsubset A}
        {
          \Delta; \Psi \vdash R \Rar S \sqsubset A
          &&
          \Delta; \Psi \vdash S \leq S' \sqsubset A
        } &
      & \infer{\Delta; \Psi \vdash \lambda x.N \Lar \Pi x{::}S \sqsubset A.S' \sqsubset \Pi x{:}A.A'}
        {
          \Delta; \Psi, x{::}S \sqsubset A \vdash N \Lar S' \sqsubset A'
        }
    \end{align*}
    \begin{align*}
      & \infer{\Delta; \Psi \vdash N \Lar S_1 \land S_2 \sqsubset A}
        {
          \Delta; \Psi \vdash N \Lar S_1 \sqsubset A
          &&
          \Delta; \Psi \vdash N \Lar S_2 \sqsubset A
        }
    \end{align*}

    % Sort/type synthesis
    $\boxed{\Omega; \Delta; \Psi \vdash_\Sigma R \Rar S \sqsubset A}$
    \begin{align*}
      & \infer{\Delta; \Psi \vdash \textbf{c} \Rar S \sqsubset A}
        {
          \textbf{c} {::} S \sqsubset A \in \Sigma
        } &
      & \infer{\Delta; \Psi \vdash x \Rar S \sqsubset A}
        {
          x {::} S \sqsubset A \in \Psi
        } 
    \end{align*}
    \begin{align*}
      \infer[(\text{for } 1 \leq k \leq n)]
            {\Delta; \Psi \vdash \proj \ k \ x \Rar [\ell_{k-1}; ..., \ell_1; \overleftarrow{M}]S_k \sqsubset [\ell_{k-1}; ..., \ell_1; \overleftarrow{M}] B_k}
            {
              x {:} \textbf{w} \ \vec{M} \in \Psi
              &&
              \textbf{w} {:} \Pi (\overrightarrow{y {::} S \sqsubset A}). \langle \ell_i {::} S_i \sqsubset B_i \rangle_n \in \Sigma
            }
    \end{align*}
    \begin{align*}
      \infer{\Delta; \Psi \vdash R \ N \Rar [N/x]S \sqsubset [N/x]A_2}
            {
              \Delta; \Psi \vdash R \Rar \Pi x{::}S_1 \sqsubset A_1. S_2 \sqsubset \Pi x{:}A_1. A_2
              &&
              \Delta; \Psi \vdash N \Lar S_1 \sqsubset A_1
            }
    \end{align*}
    \begin{align*}
      & \infer{\Delta; \Psi \vdash R \Rar S_1 \sqsubset A}
              {\Delta; \Psi \vdash R \Rar S_1 \land S_2 \sqsubset A} &
      & \infer{\Delta; \Psi \vdash R \Rar S_2 \sqsubset A}
              {\Delta; \Psi \vdash R \Rar S_1 \land S_2 \sqsubset A}
    \end{align*}
    
    \textbf{Remarks}. (1) In the rule for projections, $\overleftarrow{M}$ is just $\vec{M}$ backwards.  This is necessary since we construct spines
    from right to left, and substitutions from left to right.

    (2) Because of the last two rules regarding intersection sorts, the system is not deterministic.

    \textbf{Note}.  The rules for parameter variables, meta-variables, and closures are still missing.  

    % Substitutions
    $\boxed{\Omega; \Delta; \Psi_1 \vdash_\Sigma \sigma \Lar \Psi_2}$

    \begin{align*}
      & \infer{\Delta; \Psi_1 \vdash \cdot \Lar \cdot}{} &
      & \infer{\Delta; \Psi_1 \vdash s[\sigma] \Lar \Psi_2}
        {
          \Delta; \Psi \vdash \sigma \Lar \Psi_2'
          &&
          s{::}\Psi_2[\Psi_2'] \in \Delta
        }
    \end{align*}
    \begin{align*}
      & \infer{\Delta; \psi, \Psi \vdash \wk_\psi \Lar \psi}{} &
      & \infer{\Delta; \Psi_1 \vdash (\sigma; N) \Lar (\Psi_2, x{::}S \sqsubset A)}
        {
          \Delta; \Psi_1 \vdash \sigma \Lar \Psi_2
          &&
          \Delta; \Psi_1 \vdash N \Lar S \sqsubset A
        }
    \end{align*}
    \begin{align*}
      \infer{\Delta; \Psi_1 \vdash (\sigma; \overleftarrow{M}) \Lar (\Psi_2, x{:} \textbf{w} \ \vec{M})}
            {
              \Delta; \Psi \vdash \overrightarrow{S \sqsubset A} \Lar \Sort
              &&
              \Delta; \Psi, (\overrightarrow{x{::}S \sqsubset A}) \vdash \langle \ell_i {::} S_i \sqsubset B_i \rangle_n
            }
    \end{align*}

    \textbf{Remark}.  The premise $\Delta; \Psi \vdash \overrightarrow{S \sqsubset A} \Lar \Sort$ checks that all the sorts are valid, given that 
    the previous ones are.  Formally, this auxilliary judgment is given by the following two rules :
    \begin{align*}
      & \infer{\Delta; \Psi \vdash S \sqsubset A ; \varepsilon \Lar \Sort}{ \Delta; \Psi \vdash S \sqsubset A \Lar \Sort} &
      & \infer{\Delta; \Psi \vdash S' \sqsubset A' ; \overrightarrow{S \sqsubset A} \Lar \Sort}
        {
          \Delta; \Psi \vdash \overrightarrow{S \sqsubset A} \Lar \Sort
          &&
          \Delta; \Psi, (\overrightarrow{x{::}S \sqsubset A}) \vdash S' \sqsubset A' \Lar \Sort
        }
    \end{align*}

    % Subsorting
    $\boxed{\Omega; \Delta; \Psi \vdash_\Sigma S_1 \leq S_2 \sqsubset A }$
    
    \begin{align*}
      & \infer{\Delta; \Psi \vdash S \leq S \sqsubset A}{\Delta; \Psi \vdash S \sqsubset A} &
      & \infer{\Delta; \Psi \vdash S_1 \leq S_3 \sqsubset A}
        {
          \Delta; \Psi \vdash S_1 \leq S_2 \sqsubset A
          &&
          \Delta; \Psi \vdash S_2 \leq S_3 \sqsubset A
        }
    \end{align*}
    \begin{align*}
      & \infer{\Delta; \Psi \vdash S \leq \top \sqsubset A}{\Delta; \Psi \vdash S \sqsubset A} &
      & \infer{\Delta; \Psi \vdash \Pi x{::}S_1 \sqsubset A. S_1' \leq \Pi x{::}S_2 \sqsubset A. S_2' \sqsubset \Pi x{:}A.A'}
        {
          \Delta; \Psi \vdash S_2 \leq S_1 \sqsubset A
          &&
          \Delta; \Psi \vdash S_1' \leq S_2' \sqsubset A'
        }
    \end{align*}
    \begin{align*}
      \infer{\Delta; \Psi \vdash S \leq S_1 \land S_2 \sqsubset A}
            { 
              \Delta; \Psi \vdash S \leq S_1 \sqsubset A
              &&
              \Delta; \Psi \vdash S \leq S_2 \sqsubset A
            }
    \end{align*}
    \begin{align*}
      & \infer{\Delta; \Psi \vdash S_1 \land S_2 \sqsubset A}
        { 
          \Delta; \Psi \vdash S_1 \leq S \sqsubset A
          &&
          \Delta; \Psi \vdash S_2 \sqsubset A \Lar \Sort
        } &
      & \infer{\Delta; \Psi \vdash S_1 \land S_2 \sqsubset A}
        { 
          \Delta; \Psi \vdash S_2 \leq S \sqsubset A
          &&
          \Delta; \Psi \vdash S_1 \sqsubset A \Lar \Sort
        }
    \end{align*}

    % World well-formedness
    $\boxed{\Omega; \Delta; \Psi \vdash_\Sigma W \ \world}$
    
    \begin{align*}
      \infer{\Delta; \Psi \vdash \Pi \overrightarrow{x{::}S \sqsubset A}.\langle \ell_i {::} S_i \sqsubset B_i \rangle_n}
            {
              \Delta; \Psi \vdash \overrightarrow{ S \sqsubset A} \Lar \Sort
              &&
              \Delta; \Psi \vdash, (\overrightarrow{x{::}S \sqsubset A}) \vdash \langle \ell_i {::} S_i \sqsubset B_i \rangle_n \Lar \Rec
            }
    \end{align*}

    \textbf{Notes}. (1) The judgment for \texttt{Rec} kinds is still not defined.
    
    (2) There's also a possible alternative set of rules where we add the parameters one at a time, although it requires separated the syntactic
    category of worlds in two parts, one for records and one for parametrized records.  It also requires two corresponding notions of sub-worlds.
    So, it's a bit more verbose, but it's a lot more straightforward.

    % Schema well-formedness
    $\boxed{\Omega; \Delta; \Psi \vdash_\Sigma \Xi \ \schema}$

    \begin{align*}
      & \infer{\Delta; \Psi \vdash \varepsilon \ \schema}{} &
      & \infer{\Delta; \Psi \vdash \Xi + \textbf{w} \ \schema}
        {
          \Delta; \Psi \vdash \Xi \ \schema
          &&
          \textbf{w} {:} W \in \Sigma
          &&
          \textbf{w} \notin \Xi
        }
    \end{align*}
    
    \textbf{Note}.  The judgments for world and schema validity and only used in signature formations, which requires the contexts to be empty.
    So, they may not be needed at all in this case.

    % Schemaing of LF contexts
    $\boxed{\Omega; \Delta \vdash_\Sigma \Psi : \Xi}$
    
    \begin{align*}
      & \infer{\Omega; \Delta \vdash \cdot {:} \varepsilon}{} &
      & \infer{\Omega; \Delta \vdash \psi {:} \Xi}{\psi {:} \Xi \in \Omega} &
      & \infer{\Omega; \Delta \vdash \Psi {:} \Xi_2}
        {
          \Omega; \Delta \vdash \Psi {:} \Xi_1
          &&
          \Omega; \Delta \vdash \Xi_1 \leq \Xi_2
        }
    \end{align*}
    \begin{align*}
      \infer{\Omega; \Delta \vdash (\Psi, x{:} \textbf{w} \ \vec{M}) : \Xi}
            {
              \Omega; \Delta \vdash \Psi : \Xi
              &&
              \textbf{w} {:} \Pi \overrightarrow{x{::}S \sqsubset A}. \langle \ell_i {::} S_i \sqsubset B_i \rangle_n \in \Xi
              &&
              \Omega ; \Delta; \Psi \vdash \vec{M} \Lar \overrightarrow{S \sqsubset A}
            }
    \end{align*}

    \textbf{Note}. The judgment $\Omega; \Delta; \Psi \vdash \vec{M} \Lar \overrightarrow{S \sqsubset A}$ is just checking each of the terms in the 
    spine $\vec{M}$ against the corresponding type (which may depend on the previous terms).  Rules will be added soon.

    % Sub-worlds
    $\boxed{\Omega; \Delta; \Psi \vdash_\Sigma W_1 \leq W_2}$ \\
    
    \textbf{Note}.  This will be way easier with the aforementionned change on the syntax of worlds.\\

    % Sub-schema
    $\boxed{\Omega; \Delta; \Psi \vdash_\Sigma \Xi_1 \leq \Xi_2}$
    \begin{align*}
      & \infer{\Delta; \Psi \vdash \varepsilon \leq \Xi}{\Delta; \Psi \vdash \Xi \ \schema} &
      & \infer{\Delta; \Psi \vdash \Xi_1 + W_1 \leq \Xi_2 + W_2}
        {
          \Delta; \Psi \vdash \Xi_1 \leq \Xi_2
          &&
          \Delta; \Psi \vdash W_1 \leq W_2
        } &
      & \infer{\Delta; \Psi \vdash \Xi_1 + \Xi_2 \leq \Xi_2 + \Xi_1}{\Delta; \Psi \vdash \Xi_1 + \Xi_2 \ \schema}
    \end{align*}

    \subsection{Computation-level}
    We can lift the data-level refinements to the computation-level to obtain a restricted notion of refinements where the user does not directly
    specify any sorts.  It could be interesting to have a full blown refinement type system, and it should not complicate matters too much.

    \section{Constructor subtyping}
    TBD

    \section{Ornaments}
    TBD

    \bibliographystyle{acm}
    \bibliography{bibliography}    
\end{document}
